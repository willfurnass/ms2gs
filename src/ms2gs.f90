

!**********************************************************************
!        MS2GS: (c) Miguel Perez-Enciso (miguel.perez@uab.es)         !
!**********************************************************************

! A program to read genome data from ms file and perform genedropping simulation
! This program takes ms format file as input and produces new genomes
! according to a pedigree pedfile, and phenotypes generated by causal loci
! COMPILING:
!    make
! or
!    f95 -fcheck=all kind.f90 ALliball.f90 ebv.f90 aux_sub11.f90 ms2gs.f90
! GENERATE A MS FILE: use macs instead of ms because of few decimal digits in ms for pos.
!    macs $NIND $LENGTH -t $THETA -h 0.01 2>/dev/null | msformatter > ms.out
! USAGE:
!    ./ms2gs -ms $MSFILE -i $PARFILE [-snp $SNPFILE] [-seed $SEED] > $OUTFILE

!######################
 module types
!######################
! This module contains types needed for ms2gs, basically qtl, ind, and genome
 use kinds
 use aux_sub_m
 use random
 implicit none
 integer, parameter :: missing=-9


!--------------
 type infochip ! contains info on how to ascertain snps
!--------------
! p is % of snps selected that pass maf criterion
 real      :: maf=0, p=1.
 integer   :: min_dist=0, nmax=1d7, ind(2)=(/0,0/)
 character :: snpfile*50=' ', regfile*50=' '
 logical   :: causal=.false. !--> use only causal snps if true
!------------
 end type
!------------

!--------------
 type infosel ! contains info on selection criterion and on pop scheme
!--------------
 logical          :: rand=.true., blup=.false., y=.false., gschip=.false., &
                     gsseq=.false., gsqtl=.false., use_ascertained=.false. 
 integer          :: t, nsires, ndams, noff, nbase, ntot, nit, nindms, &
                     assortative=0, nxval=0, idx(2)=0, kmin=1, nlociB=1000, &
                     kill(2)=0
 integer, pointer :: pedig(:,:), xind(:)
 character        :: obj*4, pedfile*30,nlinear*1='0'
 real             :: pxval=0.
 real(r8)         :: s_err(3,3), &   !--> seq errors
                     i_err(3,3), &   !--> impute errors
                     g_err(3,3)      !--> chip errors
 logical          :: inbred=.false.
!----------------
 end type infosel
!----------------

!------------
 type qtl    ! contains individual qtl effects & coordinates
!------------
! ULL: ipos refers to snp order in chr rather, NOT absolute bp position
 integer   :: chr, ipos
 real      :: a, d, va, vd, va0, vd0, f
!------------
 end type qtl
!------------

!------------
 type qdensity ! qtl distribution
!------------
! f can be U, N, G for uniform, normal, gamma or caballero-keightley
 character :: f*6=' '
 real(r8)  :: x=0, s=0
!-----------------
 end type qdensity
!-----------------

!-------------
 type simu_qtl ! simulated qtl position parameters
!-------------
! f can be U or N ewens (neutral)
 character :: f*1=' '
 real      :: b(2)=(/0.,1./), r2=0
!-----------------
 end type simu_qtl
!-----------------

!------------
 type gcausal ! contains qtl effect & coordinates
!------------
! contains list of causal qtl, ind1:ind2 contains the list of individuals to be considered for freq
! sign is sign of derived allele effect, 0 if random
! vf is variance of features
 integer  :: nqtl=0, ind(2)=0
 real(r8) :: h2=0, h2obs=0, ve=0, sign=0.5, freq_range(2), z=0, p=0, threshold=0, x=0
 logical  :: init_effect = .false., & !--> if effects already defined in par file
             adjust_ve   = .false., & !--> if adjust ve to observed qtl frequencies
             pos_def     = .false., & !    precise qtl positions defined
             axa         = .false., & !--> axa epsitasis
             fdefined    = .false.    !    features defined
 integer(i8), pointer :: regs(:,:), features(:,:)
 real, pointer        :: varf(:)=>null()
 type(qtl),   pointer :: qtl(:)=>null()
 type(qdensity)       :: qdista, qdistd, qdistva, qdistvd, qdistvf
 type(simu_qtl)       :: simqtl
 character            :: ffile*40=' ', regfile*40=' '
!----------------
 end type gcausal
!----------------

!------------
 type chr    ! contains chr marker positions and both haplotype genotypes
!------------
 integer              :: nsnp=0, nchip=0, nqtl=0, ploidy=2
 integer(i8)          :: length           ! chr length in bp
 integer(i8), pointer :: pos(:)=>null()   ! snp position in bp
 integer, pointer     :: snp(:,:)=>null() ! genotype
 integer, pointer     :: chip(:)=>null()  ! contains ascertained positions, potentially several sets
 real, pointer        :: frq(:)=>null()   ! snp freqs
 real, pointer        :: map(:)=>null()   ! recombination map
 integer(i8), pointer :: bpmap(:)=>null() ! bp position dividing recombination regions
!------------
 end type chr
!------------

!------------
 type genome ! contains genome features and chrs
!------------
 integer             :: nchr=0, &
                        nqtl=0
 real                :: cM2Mb=1
 type(chr), pointer  :: ichr(:)=>null()
 character*40        :: mapfile=' '
!------------
 end type
!------------

!------------!
 type indiv  ! contains id, pedigree, sex, phenotype, ture and estimated breeding value, &
!----------- ! causal genotypes, and genome information
 integer          :: id=0, sex, parents(2)=(/0,0/)
 real(r8)         :: y,   &     ! phenotype
                     tbv, &     ! true breeding value
                     ebv(4), &  ! estimated breeding value: blup, chip, seq, qtl
                     xbv        ! predicted (xvalidation) breeeding value
 logical          :: alive = .false., &
                     sel   = .false.,  &
                     use   = .true.     !--> whether indiv is to be retained for evaluation
 integer, pointer :: g_qtl(:)=>null()
 type(genome)     :: g
!------------
 end type
!------------


!--------------
 type pop_type ! not used yet
!--------------
 integer              :: max_ind
 character            :: historyfile*40=' '
 type(indiv), pointer :: indiv(:)=>null()
 type(infosel)        :: scheme
!------------
 end type
!------------


!###############################################################################
                                 CONTAINS
!###############################################################################

!----------------------
 subroutine init_genome (genom, nchr, nsnp_chr, snp_pos, cM2Mb, chr_lengths, nqtl, frq, mapfile)
!----------------------
! first init chrlengths, cm2mb and nqtl in read_par
! rest of init in read_ms
 type(genome) :: genom
 real         :: cM2Mb
 character    :: mapfile*(*)
 integer      :: nchr, nqtl, nsnp_chr(:), frq(:), nreg, i, ic, ireg, isnp, iomap=232
 integer(i8)  :: snp_pos(:), chr_lengths(:)
 optional     :: frq, nchr, nsnp_chr, snp_pos, cM2Mb, chr_lengths, nqtl, mapfile
 integer,     allocatable :: ichr(:)
 integer(i8), allocatable :: bpos(:)
 real,        allocatable :: xrate(:)

 !--> check dimensions
 if(present(nsnp_chr)) then
    if(sum(nsnp_chr) .ne. size(snp_pos)) STOP 'In init_genome #snps <> #snp posns'
 endif

 if(present(nchr))  genom%nchr  = nchr
 if(present(nqtl))  genom%nqtl  = nqtl
 if(present(cM2Mb)) genom%cM2Mb = cM2Mb
 if (.not. associated(genom%ichr)) allocate (genom%ichr(genom%nchr))
 isnp = 0
 do ic=1, genom%nchr
    if(present(chr_lengths)) genom%ichr(ic)%length = chr_lengths(ic)
    if(present(frq)) then
       if(associated(genom%ichr(ic)%frq)) deallocate(genom%ichr(ic)%frq)
       allocate (genom%ichr(ic)%frq(nsnp_chr(ic)))
    endif
    if(present(nsnp_chr)) then
       genom%ichr(ic)%nsnp   = nsnp_chr(ic)
       if(associated(genom%ichr(ic)%pos)) deallocate(genom%ichr(ic)%pos)
       allocate (genom%ichr(ic)%pos(nsnp_chr(ic)))
       do i=1, nsnp_chr(ic)
          isnp = isnp+1
          genom%ichr(ic)%pos(i) = snp_pos(isnp)
          if(present(frq)) genom%ichr(ic)%frq(i) = frq(isnp)
       enddo
    endif
 enddo

 !--> first sets all recombination rate to defaults
 nreg = 1
 do ic=1, genom%nchr
    allocate(genom%ichr(ic)%map(nreg), genom%ichr(ic)%bpmap(nreg))
    genom%ichr(ic)%map(nreg)   = genom%cM2Mb * genom%ichr(ic)%length  * 1.d-8
    genom%ichr(ic)%bpmap(nreg) = genom%ichr(ic)%length
 enddo

 !--> reads mapfile, format is ichr bp xrate (in cM2Mb)
 !    sorted by chr and bp in ascending order
 if(present(mapfile) .and. mapfile.ne.' ') then
    genom%mapfile = mapfile
    nreg = wc(mapfile)
    if(nreg==0) RETURN
    allocate(ichr(nreg), bpos(nreg), xrate(nreg))

    open(iomap,file=mapfile)
    do i=1, nreg
       read(iomap,*) ichr(i), bpos(i), xrate(i)
       if(bpos(i) > genom%ichr(ichr(i))%length) &
          STOP 'Recombination limit cannot be larger than chr length in bp'
    enddo
    close(iomap)

    do ic=1, genom%nchr
       !--> +1 to cap to chr end just in case
       nreg = count(ichr==ic)+1
       if(nreg>1) then
          deallocate(genom%ichr(ic)%map, genom%ichr(ic)%bpmap)
          allocate(genom%ichr(ic)%map(nreg), &
                  genom%ichr(ic)%bpmap(nreg))
          ireg = 0
          do i=1, size(ichr)
             if(ichr(i) .ne. ic) CYCLE
             ireg = ireg+1
             !--> bpmap stores segment bound in bp
             genom%ichr(ic)%bpmap(ireg) = bpos(i)
             !--> map stores segment length in Morgans
             if(ireg==1) then
                genom%ichr(ic)%map(ireg) &
                  = xrate(i) * (genom%ichr(ic)%bpmap(ireg)*1d-8)
             else
                genom%ichr(ic)%map(ireg) &
                  = xrate(i) * (genom%ichr(ic)%bpmap(ireg)-genom%ichr(ic)%bpmap(ireg-1))*1d-8
             endif
          enddo
          !--> caps final segments just in case to default cM2Mb xrate
          genom%ichr(ic)%bpmap(nreg) = genom%ichr(ic)%length
          genom%ichr(ic)%map(nreg)   = genom%cM2Mb &
                                     * (genom%ichr(ic)%length-genom%ichr(ic)%bpmap(nreg-1))*1d-8
       endif
       !PRINT*, 'gh',ic, genom%ichr(ic)%map
       !PRINT*, 'gh',ic, genom%ichr(ic)%bpmap;
    enddo
    deallocate(ichr,bpos,xrate)
 endif
!--------------
 end subroutine
!--------------

!-----------------------
 subroutine print_genome (genom)
!-----------------------
! prints info in genome object
 type(genome) :: genom
 integer      :: ic, snsnp, snchip
 integer(i8)  :: slength
 snsnp=0; slength=0; snchip=0
 print'(a)', 'GENOME'
 print'(a,f6.2)', ' Default cM2Mb:', genom%cM2Mb
 if(genom%mapfile.ne.' ') print'(2a)', ' Xover map in: ',genom%mapfile

 print'(a,i6)',   ' nqtl: ', genom%nqtl
 print'(a)', ' Chr  length    no_markers  first_pos    last_pos  n_ascertained'
 do ic=1, genom%nchr
    if (genom%ichr(ic)%nsnp>0) &
    print'(i3,i10,3i12,i6)', ic, genom%ichr(ic)%length, &
                              genom%ichr(ic)%nsnp,   &
                              genom%ichr(ic)%pos(1), &
                              genom%ichr(ic)%pos(genom%ichr(ic)%nsnp), &
                              genom%ichr(ic)%nchip
    slength = slength + genom%ichr(ic)%length
    snsnp   = snsnp + genom%ichr(ic)%nsnp
    snchip  = snchip + genom%ichr(ic)%nchip
 enddo
 print'(a,i10,i12,24x,i6)', 'Sum',slength,snsnp,snchip
 print*
!--------------
 end subroutine
!--------------

!---------------------
 subroutine init_indiv (ind, id, sex, id_sire, id_dam, genom, ichr, use)
!---------------------
! fills in scalars and allocates space
! for later homework init for every type and overload subroutines
 type(indiv)  :: ind
 type(genome) :: genom
 integer      :: id, sex, id_sire, id_dam, ic, ichr
 logical      :: use
 optional     :: ichr, use !--> inits only that chr

 ind%parents = (/id_sire, id_dam/)
 ind%id      = id
 ind%sex     = sex
 ind%alive   = .true.
 ind%sel     = .false.
 ind%use     = .true.
 if(present(use)) ind%use = use
 ind%y       = missing
 ind%tbv     = missing
 ind%ebv     = missing
 ind%g%nchr  = genom%nchr
 if (genom%nqtl>0) then
    ind%g%nqtl  = genom%nqtl
    if(associated(ind%g_qtl)) deallocate(ind%g_qtl)
    allocate (ind%g_qtl(genom%nqtl))
    ind%g_qtl = 9
 endif
 if(.not. associated(ind%g%ichr)) allocate ( ind%g%ichr(ind%g%nchr) )
 do ic=1, ind%g%nchr
    if(present(ichr) .and. ic .ne. ichr) CYCLE
    ind%g%ichr(ic)%nsnp  = genom%ichr(ic)%nsnp
    ind%g%ichr(ic)%nchip = genom%ichr(ic)%nchip
    if(associated(ind%g%ichr(ic)%snp)) deallocate(ind%g%ichr(ic)%snp)
    allocate (ind%g%ichr(ic)%snp( genom%ichr(ic)%nsnp , 2 ))
 enddo
!--------------
 end subroutine
!--------------

!----------------------
 subroutine print_indiv (ind, ichr)
!----------------------
! prints info in ind object
 type(indiv)       :: ind
 integer, optional :: ichr
 integer           :: ic

 print'(a,i5)', 'INDIVIDUAL:', ind%id
 print'(a,3l2)','SEL?, ALIVE? USE?: ',ind%sel, ind%alive, ind%use
 print'(a)', ' Sire  Dam  Sex   y      BV      EBV'
 print'(2i5,i4,3f8.3)', ind%parents, ind%sex, ind%y, ind%tbv, ind%ebv
 if(associated(ind%g_qtl)) then
    print'(a,1000i2)', 'Causal genotypes:', ind%g_qtl
 endif
 if(associated(ind%g%ichr)) then
    do ic=1, ind%g%nchr
       if(present(ichr) .and. ic/=ichr) CYCLE
       print'(a,i3)', 'CHR:',ic
       write(*,'(10000000i1)') ind%g%ichr(ic)%snp(:,1)
       write(*,'(10000000i1)') ind%g%ichr(ic)%snp(:,2)
    enddo
 endif
 print*
!--------------
 end subroutine
!--------------

!---------------
 subroutine kill (ind)
!---------------
! deletes memory from type ind
 type(indiv)  :: ind
 integer      :: ic, io
 ind%alive = .false.
 do ic=1, ind%g%nchr
    if (associated(ind%g%ichr(ic)%snp)) deallocate( ind%g%ichr(ic)%snp )
    if (associated(ind%g%ichr(ic)%pos)) deallocate( ind%g%ichr(ic)%pos )
 enddo
 if (associated(ind%g%ichr)) deallocate(ind%g%ichr)
 if (associated(ind%g_qtl))  deallocate(ind%g_qtl)
!--------------
 end subroutine
!--------------

!---------------
 subroutine copy (ind1, ind2, killing)
!---------------
! copy ind1 into ind2 and optionally kills ind1
 type(indiv)       :: ind1, ind2
 logical, optional :: killing
 integer :: ic
 call kill(ind2)
 call init_indiv(ind2, ind1%id, ind1%sex, ind1%parents(1), ind1%parents(2), ind1%g )

 if(associated(ind1%g_qtl)) ind2%g_qtl = ind1%g_qtl
 ind2%y     = ind1%y
 ind2%ebv   = ind1%ebv
 ind2%tbv   = ind1%tbv
 ind2%alive = ind1%alive
 ind2%sel   = ind1%sel
 ind2%use   = ind1%use

 do ic=1, ind1%g%nchr
    ind2%g%ichr(ic)%snp = ind1%g%ichr(ic)%snp
 enddo
 if(present(killing) .and. killing) call kill(ind1)
!--------------
 end subroutine
!--------------

!---------------
 subroutine mate (id, sex, genom, son, sire, dam)
!---------------
 type(indiv)  :: son, sire, dam
 type(genome) :: genom
 integer      :: id, sex, h, ic
 optional     :: sire, dam

 call init_indiv(son, id, sex, sire%id, dam%id, genom)
 do ic=1, son%g%nchr
    if(present(sire)) son%g%ichr(ic)%snp(:,1) = meiosix(sire%g%ichr(ic)%snp,  genom%ichr(ic)%pos, &
                                                        genom%ichr(ic)%bpmap, genom%ichr(ic)%map)
    if(present(dam))  son%g%ichr(ic)%snp(:,2) = meiosix(dam%g%ichr(ic)%snp,   genom%ichr(ic)%pos, &
                                                        genom%ichr(ic)%bpmap, genom%ichr(ic)%map)
 enddo
!--------------
 end subroutine
!--------------

!------------------------
 integer function meiosis (snp, pos, cM2Mb) result(gamete)
!------------------------
! assumes a constant rate cm2Mb, Poisson distributed
! I set a maximum of 4 xovers per chr?
 integer, parameter    :: maxx=4, reverse(2)=(/2,1/)
 integer               :: snp(:,:), nsnp, nx, nnx, ih, ix
 integer(i8)           :: pos(:)
 real                  :: cM2Mb
 real(r8)              :: xlength
 real(r8), allocatable :: rpos(:)
 integer, allocatable  :: ixpos(:)
 dimension             :: gamete(size(pos))
 nsnp = size(pos)

 xlength = pos(nsnp) * 1.d-6 * cm2Mb * 0.01 !--> Morgans
 nx = min(poidev(xlength), maxx) !--> # xovers
 ih = mpe05ehf(1,2)
 gamete = snp(:,ih)
 if (nx>0) then
    allocate (rpos(nx), ixpos(nx+1))
    do ix=1,nx  !--> randomly distributed xovers
       rpos(ix)  = rxnd()*pos(nsnp)
       ixpos(ix) = count(pos<rpos(ix)) !--> probably very time consuming
    enddo
    ixpos(nx+1)=nsnp
    if(nx>1) call sortmat2(ixpos)
    nnx = count(ixpos>0)
    ixpos(1:nnx)=pack(ixpos,ixpos>0)
    do ix=1, nnx-1
       ih = reverse(ih)
       gamete(ixpos(ix):ixpos(ix+1)) = snp(ixpos(ix):ixpos(ix+1),ih)
    enddo
    deallocate(rpos,ixpos)
    !print'(1000i1)', snp(:,1)
    !print'(1000i1)', snp(:,2)
    !print'(1000i1)', gamete
 endif
!--------------
 end function
!--------------

!------------------------
 integer function meiosix (snp, pos, bpmap, map) result(gamete)
!------------------------
! allows a variable rate cm2Mb per region
! map and bppos stores bounds equal rec regions
! map contains length in Morgans
! bppos contains upper bound bp position of region, last bound is chr length
! Poisson distributed
! Partial interference: maximum set of 4 xovers per chr
 integer, parameter    :: maxx=4, reverse(2)=(/2,1/)
 integer               :: snp(:,:), nx, nnx, ih, ix
 integer(i8)           :: pos(:), bpmap(:)
 real                  :: map(:), cM2Mb !notneeded
 real(r8)              :: xlength
 integer, allocatable  :: ixpos(:)
 dimension             :: gamete(size(pos))

 !--> length in Morgans
 xlength = sum(map)
 !--> # xovers
 nx = min(poidev(xlength), maxx)

 !--> random gamete
 ih = mpe05ehf(1,2)
 gamete = snp(:,ih)
 NX=4
 if (nx>0) then
    allocate (ixpos(nx+1))
    call get_xpos(ixpos,pos,map,bpmap)
    nnx = count(ixpos>0)
    ixpos(1:nnx)=pack(ixpos,ixpos>0)
    !print*, 'yyyyyy',ixpos(1:nnx)
    do ix=1, nnx-1
       ih = reverse(ih)
       gamete(ixpos(ix):ixpos(ix+1)) = snp(ixpos(ix):ixpos(ix+1),ih)
    enddo
    deallocate(ixpos)
    !print'(1000i1)', snp(:,1)
    !print'(1000i1)', snp(:,2)
    !print'(1000i1)', gamete;STOP 'ggg'
 endif
!--------------
 end function
!--------------

!-------------------
 subroutine get_xpos (ixpos,pos,map,bpmap)
!-------------------
! get recombination points with unequal xrates
! ixpos contains # snps below the xover point
 integer     :: ixpos(:), ix, nx, i
 integer(i8) :: pos(:), bpmap(:), ixbp
 real        :: map(:)
 nx = size(ixpos)-1
 do i=1, nx
    !--> returns interval id, weighted according to cM length
    call random_loaded(ix,real(map/sum(map),r8))
    !--> now a random pos within the interval is chosen
    if(ix==1) then
       ixbp = rxnd()*bpmap(ix)
    else
       ixbp = bpmap(ix-1) + rxnd()*(bpmap(ix)-bpmap(ix-1))
    endif
    ixpos(i) = count(pos<ixbp)
 enddo

 ixpos(nx+1)=size(pos)  !--> last pos is always chr length
 if(nx>1) call sortmat2(ixpos(1:nx))
!--------------
 end subroutine
!--------------

!-----------------------
 subroutine init_gcausal (qlist, h2, va, vd, ichr, ipos, qtl_ind, sign, a, d, &
                          qdista, qdistd, qdistva, qdistvd, qtl_regs, init, &
                          adjust, pos_def, axa, ffile, vf, qfreq, py, sq)
!-----------------------
! initializes qtl values, FGWAS I need to consider features
 type(gcausal)  :: qlist
 type(qdensity) :: qdista, qdistd, qdistva, qdistvd
 type(simu_qtl) :: sq
 real           :: h2, va(:), vd(:), vf(:), a(:), d(:), qfreq(:), sign, py
 real(r8)       :: z, x
 integer        :: ichr(:), ipos(:), qtl_ind(:), nqtl, i, n, iq, iof=244
 integer(i8)    :: qtl_regs(:,:)
 logical        :: init, adjust, pos_def, axa
 character      :: ffile*(*)
 optional       :: axa, ffile, vf

 if (size(va) .ne. size(ichr) .or. size(va) .ne. size(ipos)) &
    STOP 'Wrong dimensions in qtl list'
 if(sign<0. .or. sign >1.) STOP 'P positive derived must be between 0 and 1'

 nqtl         = size(va)
 qlist%h2     = h2
 qlist%ind    = qtl_ind
 qlist%nqtl   = nqtl
 qlist%sign   = sign
 qlist%simqtl = sq
 qlist%init_effect = init
 qlist%adjust_ve   = adjust
 qlist%pos_def     = pos_def
 qlist%freq_range  = qfreq(:)
 if(present(axa))   qlist%axa = axa
 if(present(ffile) .and. ffile.ne. ' ') then
    qlist%ffile=ffile
    n=wc(ffile)
    allocate(qlist%features(n,4), qlist%varf(size(vf)))
    open(iof,file=ffile)
    do i=1, n
       read(iof,*) qlist%features(i,:)
    enddo
    close(iof)
    qlist%varf=vf
    qlist%fdefined=.true.
 endif

 !--> adjust vare if axa epistasis
 if(qlist%axa) qlist%adjust_ve = .true.

 qlist%qdista  = qdista
 qlist%qdistd  = qdistd
 qlist%qdistva = qdistva
 qlist%qdistvd = qdistvd

 !--> threshold trait, adjust ve and recompute h2u
 qlist%p = py
 if(qlist%p>0) then
    qlist%adjust_ve=.true.
 !   call ppnd16(qlist%p,x,i) !--> deviate
 !   z = dnormal(x,0.d0,1.d0) !--> normal ordinate
 !   qlist%h2 = qlist%h2 * z**2 / (qlist%p*(1.-qlist%p))
 endif

 allocate(qlist%qtl(nqtl))
 do iq=1, nqtl
    qlist%qtl(iq)%chr  = ichr(iq)
    qlist%qtl(iq)%ipos = ipos(iq)
    qlist%qtl(iq)%va   = va(iq)
    qlist%qtl(iq)%vd   = vd(iq)
    qlist%qtl(iq)%a    = a(iq)
    qlist%qtl(iq)%d    = d(iq)
 enddo

 allocate(qlist%regs(size(qtl_regs,1),size(qtl_regs,2)))
 qlist%regs = qtl_regs
!--------------
 end subroutine
!--------------

!------------------------------
 subroutine init_qtl_effect_pos (qlist, inds, gf)
!------------------------------
! FF
! sample qtl pos according to restrictions if .not.qlist%pos_def
! it assigns qtl effects to fulfill h2 and var, it computes qtl freq for inds
! overriden if a and d initialized in parameter file
! assumes qlist is initialized with qtl info
! it can recompute ve to match desired h2
 type(gcausal)     :: qlist
 type(indiv)       :: inds(:)
 type(genome)      :: gf
 real              :: f, sa, s2a, sva, svd, alpha
 real(r8)          :: aa, x, z
 real, allocatable :: vqtl_ff(:)
 integer           :: i, iq, ic, isnp, isin, signo(2)=(/-1,1/)

 !--> basic tests
 if(any(qlist%qtl(:)%chr > gf%nchr)) STOP 'QTL chr larger than no. of chromosomes'
 do iq=1, qlist%nqtl
    if(qlist%qtl(iq)%ipos > gf%ichr(qlist%qtl(iq)%chr)%nsnp) then
       print*, 'In QTL',iq,'SNP pos larger than no. SNPs',qlist%qtl(iq)%ipos
       STOP
    endif
 enddo

 !--> if features defined, classify qtls according to their var_f
 if(qlist%fdefined) then
    allocate(vqtl_ff(qlist%nqtl))
    call get_va_feature(vqtl_ff, qlist, gf)
    do iq=1, qlist%nqtl
       call random_normal(aa,0.d0,real(vqtl_ff(iq),r8))
       qlist%qtl(iq)%a=aa
    enddo
    qlist%qdistva%f=' '
    qlist%qdistvd%f=' '
    qlist%qdistd%f=' '
    qlist%qdista%f=' '
    qlist%init_effect=.true.
    qlist%adjust_ve=.true.
    deallocate(vqtl_ff)
 endif

 !--> QTL effects or variances are sampled if specified
 if(qlist%qdista%f .ne. ' ') call sample_effect(qlist%qtl(:)%a, qlist%qdista)
 if(qlist%qdistd%f .ne. ' ') call sample_effect(qlist%qtl(:)%d, qlist%qdistd, qlist%qtl(:)%a)

 !--> add variances sampled
 if(qlist%qdistva%f .ne. ' ') then
    if(qlist%init_effect) STOP 'ULL: Vars cannot be defined if qtl effects are initialized'
    call sample_effect(qlist%qtl(:)%va, qlist%qdistva)
    if(any(qlist%qtl(:)%va<0)) STOP 'Sampled additive variances must be positive'
 endif

 !--> dom variances sampled
 if(qlist%qdistvd%f .ne. ' ') then
    if(qlist%init_effect) STOP 'ULL: Vars cannot be defined if qtl effects are initialized'
    call sample_effect(qlist%qtl(:)%vd, qlist%qdistvd, qlist%qtl(:)%va)
    if(any(qlist%qtl(:)%vd<0)) STOP 'Sampled dominant variances must be positive'
 endif

 !--> overriden if add or dom effect defined in parameter file
 if(qlist%init_effect) then
    do iq=1, qlist%nqtl
       f    = 0
       ic   = qlist%qtl(iq)%chr
       isnp = qlist%qtl(iq)%ipos
       do i=1, size(inds)
          f = f + sum(inds(i)%g%ichr(ic)%snp(isnp,:))
       enddo
       f = 0.5*f/size(inds)
       qlist%qtl(iq)%f  = f
       qlist%qtl(iq)%vd = (2.*f*(1-f) * qlist%qtl(iq)%d)**2
       alpha = qlist%qtl(iq)%a + qlist%qtl(iq)%d *(1.-2.*f)
       qlist%qtl(iq)%va = 2.*f*(1-f) * alpha**2
    enddo

 !--> computes ve given h2 & va(i), h2 is (va+vd)/vp
 elseif(.not.qlist%init_effect) then
    sva = sum(qlist%qtl(:)%va)
    if(sva==0) STOP 'ERROR: At least variance of qtl add effects must be specified'
    svd = sum(qlist%qtl(:)%vd)
    qlist%qtl(:)%a = 0
    qlist%qtl(:)%d = 0
    qlist%ve = (sva+svd) * (1. - qlist%h2) / qlist%h2

    !--> computes qtl freq among inds, and solves for add & dominance effect
    do iq=1, qlist%nqtl
       f    = 0
       ic   = qlist%qtl(iq)%chr
       isnp = qlist%qtl(iq)%ipos
       do i=1, size(inds)
          f = f + sum(inds(i)%g%ichr(ic)%snp(isnp,:))
       enddo
       f = 0.5*f/size(inds)
       qlist%qtl(iq)%f = f
       !--> qlist%sign is % of derived mutations (1) increasing phenotypes
       isin = -1
       if(rxnd() <= qlist%sign) isin=1
       if(f>0 .and. f<1.) then
          qlist%qtl(iq)%d = isin * sqrt(0.5 * qlist%qtl(iq)%vd / (f*(1.-f)))
          qlist%qtl(iq)%a = isin * sqrt(0.5 * qlist%qtl(iq)%va / (f*(1.-f))) - qlist%qtl(iq)%d * (1-2*f)
       else
          qlist%qtl(iq)%a = 0.
          qlist%qtl(iq)%d = 0.
       endif
    enddo
 endif

 !--> if adjust_ve, I recompute ve to accommodate desired h2
 !    obligatory if feature defined
 if(qlist%adjust_ve) then
    sa  = 0.
    s2a = 0.
    do i=1, size(inds)
       inds(i)%tbv = get_tbv(inds(i),qlist)
       sa  = sa  + inds(i)%tbv
       s2a = s2a + inds(i)%tbv**2
    enddo
    sva = (s2a - sa**2/size(inds)) / (size(inds)-1.)
    qlist%ve = sva * (1. - qlist%h2) / qlist%h2

    !--> for threshold traits I need to compute the threshold, given sva and mean
    call ppnd16(qlist%p,x,i)
    qlist%threshold = x*sqrt(sva) + (sa/size(inds))
 endif
!--------------
 end subroutine
!--------------

!-----------------------------------------
 subroutine get_va_feature (vqtl, qlist, gf)
!-----------------------------------------
! it computes variance of additive qtl effects as sum of variances adscribed to each feature
! it does so by reading from file to which this qtl belongs
 type(gcausal) :: qlist
 type(genome) :: gf
 integer   :: iof=244, iq, nf, jf, ifeature
 real      :: vqtl(:)
 character :: chr*10, pos*10, b*200, c*1="'\" !trick
 vqtl=0
 do iq=1, qlist%nqtl
     !--> awk command to extract only those qtl features
     write(chr,'(i10)') qlist%qtl(iq)%chr
     write(pos,'(i10)') gf%ichr(qlist%qtl(iq)%chr)%pos(qlist%qtl(iq)%ipos)
     !--> trick to print only features within range of qtl pos
     b="awk '$1==" // trim(chr) // ' && $2<=' // trim(adjustl((pos))) // ' && $3>=' // trim(adjustl(pos)) &
        // " {print $4}" //c// ' ' // qlist%ffile // "> temp"
     call system (b)

     nf=wc('temp')
     if(nf>0) then
        open(iof,file='temp')
        do jf=1,nf
           read(iof,*) ifeature
           if(ifeature > size(qlist%varf)) then
               print*, '# features exceeded: ifeat, max',ifeature,size(qlist%varf)
               STOP
           endif
           vqtl(iq) = vqtl(iq) + qlist%varf(ifeature)
        enddo
        close(iof,status='delete')
     else
        vqtl(iq) = 1
     endif
 enddo
!--------------
 end subroutine
!--------------

!------------------------
 subroutine print_gcausal (qlist,gf)
!------------------------
 type(gcausal) :: qlist
 type(genome)  :: gf
 integer       :: iq, ic, iff, ipos, isnp, nf
 integer,allocatable :: z(:), ifq(:)
 real, allocatable   :: vaz(:), evaz(:)

 print'(a)', 'GCAUSAL'
 print'(a,f7.3,g10.3)', ' h2  ve', qlist%h2, qlist%ve
 if(qlist%qdista%f  .ne. ' ') print'(2a,2f10.3)',' Distribution add effects: ',qlist%qdista
 if(qlist%qdistd%f  .ne. ' ') print'(2a,2f10.3)',' Distribution dom effects: ',qlist%qdistd
 if(qlist%qdistva%f .ne. ' ') print'(2a,2f10.3)',' Distribution va: ',qlist%qdistva
 if(qlist%qdistvd%f .ne. ' ') print'(2a,2f10.3)',' Distribution vd: ',qlist%qdistvd
 print'(a,2i5)',' Ids used for QTL parameters: ',qlist%ind
 if (.not.qlist%pos_def) then
    print'(a)', ' QTL regions defined are (CHR begin end):'
    do iq=1,size(qlist%regs,1)
       print'(i4,2i9)', qlist%regs(iq,:)
    enddo
 endif
 if(qlist%fdefined) then
    print'(a)', ' Feature    nQTL    va    E(va)'
    nf=size(qlist%varf)+1
    allocate(z(nf),ifq(nf),vaz(nf),evaz(nf))
    vaz=0.; evaz=0.; ifq=0
    do iq=1, qlist%nqtl
        ic   = qlist%qtl(iq)%chr
        isnp = qlist%qtl(iq)%ipos
        call do_z(z,gf%ichr(ic)%pos(isnp),ic,qlist%features)
        print*, iq,z
        vaz  = vaz + z*qlist%qtl(iq)%va
        evaz = evaz + z*(2*qlist%qtl(iq)%f*(1.-qlist%qtl(iq)%f)*qlist%qtl(iq)%a**2)
        ifq  = ifq+z
    enddo
    do iq=1, nf
       print'(2i6,2f12.3)', iq, ifq(iq), vaz(iq), evaz(iq)
    enddo
    deallocate(z,vaz,evaz,ifq)
 endif
 print'(a)', ' QTL  chr    pos     (bp)       va        vd        a         d         f'
 do iq=1, qlist%nqtl
    ic   = qlist%qtl(iq)%chr
    ipos = qlist%qtl(iq)%ipos
    print'(i4,i5,i7,i9,5f10.3)', iq, ic, ipos, gf%ichr(ic)%pos(ipos), &
                  qlist%qtl(iq)%va, qlist%qtl(iq)%vd, qlist%qtl(iq)%a, &
                  qlist%qtl(iq)%d, qlist%qtl(iq)%f
 enddo
 print*
!--------------
 end subroutine
!--------------


!----------------
 subroutine do_z (z,pos,ic,f)
!----------------
! returns incidence vector for features
! q contains feature indices within bounds, slack just in case sam feature defined several times
 integer     :: z(:), i, ic, q(4*size(z))
 integer(i8) :: pos, f(:,:)
 z=0; q=0
 q=pack(f(:,4),  mask=(f(:,1)==ic .and. f(:,2)<=pos .and. pos<=f(:,3)) )
 z(pack(q,q>0))=1
 if(count(q>0)==0) z(size(z))=1 !--> dummy feature
!--------------
 end subroutine
!--------------

!---------------------
 subroutine sample_pos (qlist, gf, inds)
!---------------------
! sample qtl positions within prespecified qtl_regs, assumes gf defined with snp pos
! ipos is snp order so we need to check nearest SNP to sampled position
 type(gcausal):: qlist
 type(genome) :: gf
 type(indiv)  :: inds(:)
 integer      :: nqtl, ntot, i, ic, &
                 i1, i2, ij, sumsnp, isnp
 real(r8)     :: f
 integer,     allocatable :: snpchr(:), snpid(:), sites(:,:), isite(:)
 integer(i8), allocatable :: snppos(:)

 nqtl = qlist%nqtl

 ntot = sum(gf%ichr(:)%nsnp)
 allocate (snpchr(ntot), snpid(ntot), snppos(ntot))
 snpid(:)  = (/(-i, i=1,ntot)/) !--> negative id trick to init
 !print*, snpid,'iii'

 !-> spread out positions
 do ic=1,gf%nchr
    i2 = sum(gf%ichr(1:ic)%nsnp)
    i1 = i2 - gf%ichr(ic)%nsnp + 1
    snpchr(i1:i2) = ic
    snppos(i1:i2) = gf%ichr(ic)%pos(:)
 enddo

 !--> allowed positions
 do i=1, size(qlist%regs,dim=1)
    where(snpchr == qlist%regs(i,1)  .and. &
          snppos >= qlist%regs(i,2)  .and. &
          snppos <= qlist%regs(i,3)) snpid = -snpid
    !--> allowed positions should now be positive, or negative if no MAF requirement
    !print*, 'llz',qtlregs(i,:), count(snpid>0), count(snppos >= qtlregs(i,2) .and. snppos <= qtlregs(i,3))
 enddo

 !--- further filter by MAF qtl
 if(qlist%freq_range(1)>0.d0 .or. qlist%freq_range(2)<1.d0) then
    isnp = 0
    do ic=1, gf%nchr
       do ij=1, gf%ichr(ic)%nsnp
          isnp=isnp+1
          !--> already discared snps are not evaluated
          if(snpid(isnp)<0) CYCLE
          f =  0
          do i=1, size(inds)
             f = f + sum(inds(i)%g%ichr(ic)%snp(ij,:))
          enddo
          f=f/(2*size(inds))
          if(f<=qlist%freq_range(1) .or.  f>=qlist%freq_range(2)) snpid(isnp)=-snpid(isnp)
        enddo
    enddo
 endif

 !--> sample
 i1 = count(snpid>0)
 if(i1<nqtl) then
    print*, 'No. of allowed causal SNPs',i1,' smaller than predetermined no. QTL',nqtl
    STOP
 endif

 !snpid(1:i1) = pack(snpid, snpid>0)
 !call random_permu(snpid(1:i1)) !very very slOOOOOOOOOw
 
 !--> chooses a random position, to avoid repetition, every chosen position is zeroed out
 allocate(isite(nqtl))
 do i=1, nqtl
    snpid(1:i1) = pack(snpid, snpid>0)
    isnp = int(rxnd()*i1)+1
    isite(i) = snpid(isnp)
    snpid(isnp) = 0
    i1 = count(snpid>0)
 enddo
  
 !--> assign, ipos is snp order
 do i=1, nqtl
    !ic = snpchr(snpid(i))
    !qlist%qtl(i)%chr  = snpchr(snpid(i))
    !qlist%qtl(i)%ipos = snpid(i)
    ic = snpchr(isite(i))
    qlist%qtl(i)%chr  = snpchr(isite(i))
    qlist%qtl(i)%ipos = isite(i)
    qlist%qtl(i)%ipos = qlist%qtl(i)%ipos - sum(gf%ichr(1:ic-1)%nsnp)
 enddo

 !--> sort by position
 allocate(sites(2,nqtl))
 sites(1,:)=qlist%qtl(:)%chr; sites(2,:)=qlist%qtl(:)%ipos
 call sortmat(sites,[1,2])
 qlist%qtl(:)%chr  = sites(1,:)
 qlist%qtl(:)%ipos = sites(2,:)
 deallocate(snppos, snpchr, snpid, sites, isite)
!--------------
 end subroutine
!--------------

!------------------------
 subroutine sample_effect (eff, qd, effa)
!------------------------
 type(qdensity) :: qd
 real           :: eff(:)
 real(r8)       :: eff8(size(eff))
 integer        :: neff,i
 real, optional :: effa(:)
 select case (qd%f(1:1))
   case('U','u') !--> uniform effect
     call random_number(eff8)
     eff = qd%x + eff8 * (qd%s-qd%x)
   case('N','n') !--> normal effect
     call random_normal (eff8, real(qd%x,r8), real(qd%s,r8))
     eff = eff8
   case('G','g') !--> gamma effect
     call random_gamma_v(real(qd%x,r8), real(qd%s,r8), eff8)
     eff = eff8
   case('C','c') !--> caballero-keightley 1994 [0 - exp-Ks]
     call random_number(eff8)
     eff = eff8 * exp(-qd%x * effa)
   case default
     print*, 'Unknown QTL distribution: ', qd%f
     STOP
 end select
!--------------
 end subroutine
!--------------


!-------------------------
 real(r8) function get_tbv (ind, qlist)
!-------------------------
 type(gcausal) :: qlist
 type(indiv)   :: ind
 integer       :: iq, ic, ipos, delta(0:2)=(/0,1,0/)
 !--> additive model
 if(.not.qlist%axa) then
    get_tbv = 0.
    do iq=1, qlist%nqtl
       ic   = qlist%qtl(iq)%chr
       ipos = qlist%qtl(iq)%ipos
       ind%g_qtl(iq) = sum(ind%g%ichr(ic)%snp(ipos,:))
       get_tbv = get_tbv + qlist%qtl(iq)%a * (ind%g_qtl(iq) - 1) &
                         + qlist%qtl(iq)%d * delta(ind%g_qtl(iq))
    enddo
 !--> axa epistasis
 else
    get_tbv = 1.
    do iq=1, qlist%nqtl
       ic   = qlist%qtl(iq)%chr
       ipos = qlist%qtl(iq)%ipos
       ind%g_qtl(iq) = sum(ind%g%ichr(ic)%snp(ipos,:))
       select case (ind%g_qtl(iq))
         case (0)
           if(qlist%qtl(iq)%a<0) get_tbv = get_tbv * (1.+abs(qlist%qtl(iq)%a))
         case (1)
           get_tbv = get_tbv * (1 + abs(qlist%qtl(iq)%a)*qlist%qtl(iq)%d)
         case (2)
           if(qlist%qtl(iq)%a>0) get_tbv = get_tbv * (1.+qlist%qtl(iq)%a)
       end select
    enddo
 endif
!------------
 end function
!------------

!----------------
 subroutine get_y (ind, qlist)
!----------------
! generates phenotype and allocates ind(:)%g_qtl and ind(:)%tbv
 type(gcausal) :: qlist
 type(indiv)   :: ind
 real(r8)      :: z

 !--> add random residual
 ind%tbv = get_tbv(ind,qlist)
 call random_normal(z)
 ind%y = ind%tbv + z * sqrt(qlist%ve)
 !print*, 'yyy',ind%id,ind%tbv,ind%y
 if (qlist%p>0) then
    if(ind%y>qlist%threshold) then
       ind%y=1
    else
       ind%y=0
    endif
 endif
!--------------
 end subroutine
!--------------


!--------------------
 subroutine init_chip (chip, maf, p, snpfile, regfile, ind)
!--------------------
 type(infochip)      :: chip
 integer, optional   :: ind(:)
 real, optional      :: maf, p
 character, optional :: snpfile*(*), regfile*(*)
 if(present(snpfile) .and. snpfile .ne. ' ') then
    chip%snpfile = snpfile
    chip%ind     = 1
 endif
 if(present(regfile) .and. regfile .ne. ' ')  then
    chip%regfile = regfile
    chip%ind     = 1 !--> so far I take all snps in those regions
 endif
 if(present(maf)) chip%maf = maf
 if(present(p))   chip%p   = p
 if(present(ind)) chip%ind = ind(1:2)  !--> first and last indiv to be ascertained
!--------------
 end subroutine
!--------------

!---------------------
 subroutine print_chip (chip, gf)
!---------------------
type(infochip)   :: chip
type(genome)     :: gf
integer          :: ic
print'(a)', 'ASCERTAINMENT'
print'(a,2i4)', ' Inds used for ascertainment:',chip%ind
if(chip%snpfile.ne.' ') then
   print'(a)', ' SNPs read from file: '//chip%snpfile
else
   if(chip%regfile.ne.' ') print'(a)', ' SNP regions read from file: '//chip%regfile
   print'(a,f4.2)', ' Minimum MAF:  ', chip%maf
   print'(a,f4.2)', ' Perc. chosen: ', chip%p
endif
!print'(a)', 'Markers chosen: chr, nsnp, order'
!do ic=1, gf%nchr
!   print'(i3,i5,100000i4)', ic, gf%ichr(ic)%nchip
!enddo
print*
!--------------
 end subroutine
!--------------

!----------------------
 subroutine init_scheme (scheme, pedfile, criter, ngen, nsires, ndams, noff, use_asc, &
                         px, nx, idx, nms, perr, kmin, nonl, nlociB, kill)
!----------------------
! initializes main selection scheme properties
 type(infosel) :: scheme
 character     :: pedfile*(*), criter*(*)
 integer       :: ngen, nsires, ndams, noff, nms, nx, kmin, ioped=111, i, nind, io, idx(:), &
                  nlociB, kill(:)
 logical       :: use_asc
 character(len=1):: nonl
 real          :: px, perr(:)

 scheme%t       = ngen
 scheme%nindms  = nms
 scheme%nsires  = nsires
 scheme%ndams   = ndams
 scheme%noff    = noff
 scheme%pedfile = pedfile
 scheme%nit     = nsires * ndams * noff !-> n per generation
 scheme%use_ascertained = use_asc !--> snp ascertained indivs used?
 scheme%pxval   = px   !--> % of individuals removed for xval
 scheme%nxval   = nx   !--> no. of xval replicates
 scheme%idx     = idx(1:2)
 scheme%kill    = kill(1:2)
 scheme%kmin    = kmin !--> min no. of alleles not be considered an error
 scheme%nlinear = nonl
 scheme%nlociB  = nlociB !--> # ncausal in Vanraden's B

 !--> init no errors
 scheme%g_err = 0; scheme%s_err=0; scheme%i_err=0
 do i=1, 3
    scheme%g_err(i,i)=1
    scheme%s_err(i,i)=1
    scheme%i_err(i,i)=1
 enddo

 !--> errors assigned
 if(perr(1) .ne. 0.) then
    scheme%g_err(:,:) = 0.5*perr(1)
    do i=1,3
       scheme%g_err(i,i)=1.-perr(1)
    enddo
 endif

 if(perr(2) .ne. 0.) then
    scheme%s_err(1,:) = [1.-perr(2)/5., perr(2)/5.,   0.]
    scheme%s_err(2,:) = [perr(2),       1.-2*perr(2), perr(2)]
    scheme%s_err(3,:) = [0.,            perr(2)/5.,   1.-perr(2)/5.]
 endif

 if(perr(3) .ne. 0.) then
    scheme%i_err = 0.5*perr(3)
    do i=1,3
       scheme%i_err(i,i)=1.-perr(3)
    enddo
 endif

 select case(criter)
   case ('rand')
     scheme%rand = .true.
     scheme%obj = 'rand'
   case ('blup')
     scheme%blup = .true.
     scheme%obj  = 'blup'
   case ('y', 'phen')
     scheme%y = .true.
     scheme%obj = 'phen'
   case ('gs', 'gsel', 'gschip')
     scheme%gschip = .true.
     scheme%obj    = 'gs_chip'
   case ('gsseq', 'gseq')
      scheme%gsseq = .true.
      scheme%obj   = 'gs_seq'
 end select

 if (pedfile /= ' ') then
    open(ioped,file=pedfile)
    nind = 0
    do
       read(ioped,*,iostat=io)
       if(io.ne.0) EXIT
       nind=nind+1
    enddo
    if(nind==0) RETURN
    allocate(scheme%pedig(nind,4))
    rewind ioped

    !--> ascertain sexes, random sex by default
    scheme%pedig(:,4) = mpe05ehf_v(1,2,nind)
    do i=1, nind
       read(ioped,*) scheme%pedig(i,1:3)
       if((.not.any(scheme%pedig(1:i,1)==scheme%pedig(i,2)) .and. scheme%pedig(i,2)>0).or. &
          (.not.any(scheme%pedig(1:i,1)==scheme%pedig(i,3)) .and. scheme%pedig(i,3)>0) ) then
          print*, 'unknown id parent',scheme%pedig(i,1:3)
          STOP
       endif
       !--> male
       where(scheme%pedig(:,1) == scheme%pedig(i,2) .and. scheme%pedig(i,2)>0)  scheme%pedig(:,4)=1
       !--> female
       where(scheme%pedig(:,1) == scheme%pedig(i,3) .and. scheme%pedig(i,3)>0 ) scheme%pedig(:,4)=2
    enddo
    close(ioped)

    !--> basic tests
 endif

 !--> total nind in the whole experiment, excluding base individuals read in ms
 scheme%ntot = scheme%t * scheme%nsires * scheme%ndams * scheme%noff
 if(associated(scheme%pedig)) scheme%ntot = scheme%ntot + size(scheme%pedig,dim=1)
!--------------
 end subroutine
!--------------

!-----------------------
 subroutine print_scheme (scheme)
!-----------------------
 type(infosel) :: scheme
 print'(a)', 'SCHEME criterion: '
 if(scheme%inbred) then
    print'(a)', ' Inbred founders assumed in ms file'
 else
    print'(a)', ' Diploid founders assumed in ms file'
 endif
 print'(a,i6)',  ' No. indivs read in msfile:  ',  scheme%nbase
 if(scheme%kill(1)>0) print'(a,2i4)', ' Inds. deleted for GBLUP: ', scheme%kill
 if(scheme%pedfile /= ' ') then
    print'(a,i6)',  ' No. indivs read in pedfile: ',  size(scheme%pedig,dim=1)
    print'(a,2i6)', ' Id range in pedfile:        ',  minval(scheme%pedig(:,1)), maxval(scheme%pedig(:,1))
    print'(2a,i6)', ' Pedfile: ', trim(scheme%pedfile)
 else
    print'(a)', ' No pedigree provided'
 endif
 if(scheme%nlinear /= '0') print'(2a,i5)', ' Van Raden non-linear approach',scheme%nlinear, scheme%nlociB
 !print'(3(a,i3))', 'Nsires:', scheme%nsires, ', ndams:', scheme%ndams, ', noff/dam:', scheme%noff
 print'(a,f6.4,i4)',  ' NGS error rate & Kmin: ', scheme%s_err(2,1), scheme%kmin
 print'(a,f6.4)',     ' Impute error rate:     ', scheme%i_err(2,1)
 print'(a,f6.4)',     ' Chip error rate:       ', 2*scheme%g_err(1,2)
 print*
!--------------
 end subroutine
!--------------


!######################
 END MODULE types
!######################

!######################
 MODULE mbe
!######################
! several functions for evolution
 use aux_sub_m

 CONTAINS

!---------------------
 real function ewens_p (n) result(ewens)
!---------------------
 integer    :: i, k, n
 dimension  :: ewens(n-1)
 do i=1, n-1
    ewens(i)=1./i
 enddo
 ewens = ewens/sum(ewens)
!------------
 end function
!------------

!----------------------------
 subroutine simulate_genotype (gnew,g,r2,q1)
!----------------------------
! simulates genotypes with freq f=q1 and r2 conditional on marker g
! note that gnew and g are vectorized and converted back into matrices
 integer :: gnew(:), g(:), i, n, n1, n0, n11, n10, n01, icode(size(g))
 real    :: r2, p1, p11, q1

 gnew = 0
 n  = size(g)
 n1 = count(g==1)
 n0 = n - n1
 p1 = sum(g)/real(n)

 !--> frequency of 11, 10 & 01 haplotypes
 p11  = sqrt(r2*p1*(1.-p1)*q1*(1.-q1)) + p1*q1
 n11  = min(nint(p11*n), nint(p1*n))
 n10  = max(0,int(p1*n - n11))
 n01  = max(0,int(q1*n - n11))

 !--> now sample n11 among the n1-
 icode(1:n) = (/(i, i=1,n)/)
 call random_permu(icode)              ! contains random ids
 icode(1:n1) = pack(icode,g(icode)==1) ! contains random positions of g==1
 gnew(icode(1:n11)) = 1
 icode(1:n0) = pack(icode,g(icode)==0) ! contains random positions of g==0
 gnew(icode(1:n01)) = 1
!--------------
 end subroutine
!--------------

!######################
 END MODULE mbe
!######################


!#########################################################################################################
!                                       MAIN PROGRAM
!#########################################################################################################

!######################
    PROGRAM ms2GS
!######################

use types
use EBV
use mbe
implicit none

!--> control type
type dothis
 logical      :: blup=.true., chip=.true., qtl=.true., seq=.true., xval=.false., &
                 fit=.true., print_ms=.false., print_sol=.false., print_plink=.false., &
                 print_yg=.false.
 character*30 :: outfile='ms2gs', ebvfile, solfile(3)='', plinkfile(6)='', outmsfile=''
end type

!--> main working variables
type(dothis)             :: doit
type(indiv), allocatable :: ind(:)
type(gcausal)            :: qlist
type(infochip)           :: chip      ! info on how snps selected
type(infosel)            :: selscheme ! info on selection
type(genome)             :: gfeatures
integer                  :: nind=0

!--> aux variables
character :: msfile*50      = 'ms2gs.ms',  &
             parfile*50     = ' ', &
             historyfile*50 = ' ', &
             solfile(3)*50  = 'ms2gs', &
             plinkfile(6)*50= 'ms2gs', &
             mscommand*1000 = ' ', &
             cmd*200, xc(100)*50, path*50
integer   :: i, n, nped, t, ic, id, isire, idam, isex, nsires, ndams, noff, &
             ntot, niter=0, iter, v(8), seed(12), &
             ioplink(6) = [14,15,16,17,18,19], g(20), g2(20)
real      :: x(size(xc))
real(r8)  :: rho(5)=0, rhox(5)=0
logical   :: out_defined  = .false., &
             ms_defined   = .false., &
             snp_defined  = .false., &
             seed_defined = .false., &
             print_sol    = .false., &
             print_plink  = .false., &
             inplink      = .false., &
             noquiet      = .true.
integer, allocatable  :: use(:)
real(r8), allocatable :: snpsol(:)

 !--> random seed, it can be initialized with -seed or in parfile
 call date_and_time(values=v)
 seed = sum(v)+1000*v(8)+100*v(7)*v(6)
 if(noquiet) call print_date_and_time(label='ms2gs-v0.1',oneline=.true.)

!######### read parameters
 call get_command (cmd)
 if(noquiet) print*, cmd
 call nums2 (cmd, n, x, xc)
 do i=2, n
   select case (xc(i))
      case ('-h', '-help')
        !--> trick to extract last instance of '/' and thence the path to ms2gs
        path = xc(1)(1:index(xc(1),'/',back=.true.))
        call system('cat '//trim(path)//'README.ms2gs')
        STOP
      case ('-i')
        parfile = xc(i+1)
      case ('-quiet')
        noquiet = .false.  
      case ('-ms')
        msfile = xc(i+1)
        ms_defined = .true.
      case ('-snp')
        chip%snpfile = xc(i+1)
        snp_defined = .true.
      case ('-rsnp')
        chip%regfile = xc(i+1)
        snp_defined = .true.
      case ('-seed')
        seed = x(i+1)
        seed_defined = .true.
      case ('-niter')
        niter = x(i+1)
   end select
 enddo

!######### read parameter file: init qlist, chip, sel scheme & genome
 call read_par(parfile, qlist, chip, selscheme, gfeatures, mscommand, &
               msfile, niter, out_defined, ms_defined, snp_defined, &
               seed_defined, seed, inplink, doit)
              
 call random_seed(put=seed)

DO ITER=1, NITER

 if(mscommand .ne. ' ') call system (trim(mscommand) // ' >' // msfile)

 !--> counts how many individuals in ms or plink file (misses sel breeding), some tests
 if(iter == 1) then
    if(inplink) then
       nind = wc(adjustl(trim(msfile))//'.ped')
    else
       nind = (wc(msfile)-2)/gfeatures%nchr - 4
       if(.not.selscheme%inbred) nind = nind/2   !--> outbred
    endif
    !--> creates dummy pedig if no pedfile absent
    if(associated(selscheme%pedig)) then
       nind = max(nind,maxval(selscheme%pedig(:,1)))
    else
       allocate(selscheme%pedig(nind,4))
       selscheme%pedig = 0
       selscheme%pedig(:,1) = [(i, i=1,nind)]
    endif
    allocate (ind(nind))
 
 endif
 
 !--> read plink or ms data:  init indivs and gfeatures
 if(inplink) then
    call read_plink(msfile, ind, selscheme, gfeatures, chip)
 else
    !--> call system with coalescence simulation if mscommand provided
    call read_ms(msfile, ind, selscheme, gfeatures, chip)
 endif 

 !--> if no qtl inds or chip inds, all base individuals considered
 if(chip%ind(2)==0)  chip%ind(2) = selscheme%nbase
 if(qlist%ind(2)==0) qlist%ind(2)= selscheme%nbase
 !--> if no xval ids, all non base by default
 if(sum(selscheme%idx)==0) selscheme%idx =[selscheme%nbase+1, maxval(selscheme%pedig(:,1))]

 !--> check input
 if(any(qlist%ind < 0) .or. any(qlist%ind > selscheme%nbase) ) STOP 'Wrong range in QTL indivs'
 if(any(chip%ind < 0)  .or. any(chip%ind  > selscheme%nbase) ) STOP 'Wrong range in CHIP indivs'
 if(any(selscheme%idx < 0)  .or. any(selscheme%idx  > nind) )  STOP 'Wrong range in XVAL indivs'

 !--> sample qtl positions if needed
 if (.not.qlist%pos_def) call sample_pos(qlist, gfeatures, ind(qlist%ind(1):qlist%ind(2))) 
 
 !--> sample qtl genotypes: update gfeatures & ind%genotypes
 if (qlist%simqtl%f .ne. ' ') call sample_new_snps(qlist,gfeatures,ind(1:selscheme%nbase)) 
 
 !--> get qtl additive effects, assumes qlist already initialized, considers features
 call init_qtl_effect_pos (qlist, ind(qlist%ind(1):qlist%ind(2)), gfeatures)

 !--> snps ascertained in samples chip%ind1:ind2
 call ascertain_snp (gfeatures, chip, ind(chip%ind(1):chip%ind(2)))
 
 !--> some printing
 if(noquiet) then
    call print_scheme(selscheme)
    call print_chip(chip,gfeatures)
    call print_genome(gfeatures)
    call print_gcausal(qlist,gfeatures)
 endif

 !--> pedig always exist, even if dummy
 nped = size(selscheme%pedig,dim=1)
 do i=1, nped
    id = selscheme%pedig(i,1)
    !--> by default only ids in pedig as alive
    ind(id)%use = .true.
    !--> base population indivs, provided in ms file
    if(id > selscheme%nbase) then
       isire = selscheme%pedig(i,2)
       idam  = selscheme%pedig(i,3)
       isex  = selscheme%pedig(i,4)
       !--> WARNING: id read is also order
       call mate(id,isex,gfeatures,ind(id),ind(isire),ind(idam))
    elseif (sum(selscheme%pedig(i,2:3))>0) then
       print*, 'WARNING: id below nbase with parents in pedigree (parents set to unknown):',id
    endif
    call get_y(ind(id), qlist)
 enddo
 
 !--> inds used for evaluation 
 if(iter==1) then
    if(selscheme%kill(2)>0) ind(selscheme%kill(1):selscheme%kill(2))%use = .false.
    allocate(use(count(ind%use)))
    use = pack([(i,i=1,nind)],ind%use)
 endif
 
 !--> get ebvs, subset of those alive and in ped file
 if(doit%fit) then
    call get_ebv('y', rho(1), ind(selscheme%pedig(:,1)), qlist, gfeatures, selscheme, historyfile, &
                 qlist%h2, ind(selscheme%pedig(:,1))%ebv(1))
    if(doit%blup) call get_ebv('blup', rho(2), ind(selscheme%pedig(:,1)), qlist, gfeatures, selscheme, historyfile, &
                 qlist%h2, ind(selscheme%pedig(:,1))%ebv(1))
    if(doit%chip) call get_ebv('gschip',rho(3), ind(use), qlist, gfeatures, selscheme, historyfile, &
                 qlist%h2, ind(use)%ebv(2), doit%solfile(1), doit%print_sol)
    if(doit%seq) call get_ebv('gsseq', rho(4), ind(use), qlist, gfeatures, selscheme, historyfile, &
                 qlist%h2, ind(use)%ebv(3), doit%solfile(2), doit%print_sol)
    if(doit%qtl) call get_ebv('gsqtl', rho(5), ind(use), qlist, gfeatures, selscheme, historyfile, &
                 qlist%h2, ind(use)%ebv(4), doit%solfile(3), doit%print_sol)
    print*, iter, 'FIT  rho Y BLUP CHIP SEQ QTL:',real(rho)
 endif
     
!--> performs crossvalidation, % is in selscheme%pxval, nrep is in selscheme%nxval
 if(doit%xval) then
    if(doit%blup) call xval_ebv('blup',  rhox(2), ind(selscheme%pedig(:,1)), qlist, gfeatures, &
                                 selscheme, historyfile, qlist%h2)
    if(doit%chip) call xval_ebv('gschip',rhox(3), ind(use), qlist, gfeatures, &
                                 selscheme, historyfile, qlist%h2)
    if(doit%seq) call xval_ebv('gsseq', rhox(4), ind(use), qlist, gfeatures, &
                                selscheme, historyfile, qlist%h2)
    if(doit%qtl) call xval_ebv('gsqtl', rhox(5), ind(use), qlist, gfeatures, &
                                selscheme, historyfile, qlist%h2)
    print*, iter, 'XVAL rho Y BLUP CHIP SEQ QTL:        NA      ',real(rhox(2:))
 endif
 
 if(noquiet) call print_stats (ind(selscheme%pedig(:,1)), gfeatures, qlist)

 !--> breeding scheme
 if(selscheme%t>0) then
    nsires = selscheme%nsires
    ndams  = selscheme%ndams
    noff   = selscheme%noff
    ntot   = selscheme%t * nsires * ndams * noff
    do t=1, selscheme%t
       !--> produces new offspring and 'kill' parents, random or assortative mating
       !call breed_new_generation(ind, selscheme, gfeatures, qlist, historyfile)
       !--> select individuals
       !call get_ebv(ind, gfeatures, selscheme, historyfile)
       !--> among alive, sets to status selected or not
       !call select(ind, selscheme)
    enddo
 endif

 !---> print file in solveSNP format
 if(doit%print_plink) then
    if(doit%chip) call print_data('chip', doit, ind(selscheme%pedig(:,1)), gfeatures, &
                                  qlist, raw=.false.)
    if(doit%seq)  call print_data('seq', doit, ind(selscheme%pedig(:,1)), gfeatures, &
                                  qlist, raw=.false.)
    if(doit%qtl)  call print_data('qtl', doit, ind(selscheme%pedig(:,1)), gfeatures, &
                                  qlist, raw=.false.)
 endif
 
 !--> print phenotypes, true and estimated breeding values
 if(doit%print_yg) call print_ebv(doit, ind(selscheme%pedig(:,1)))
  
ENDDO !--> end ms iter simulations

if(noquiet) print*, 'USED SEED:', seed(1)
 
!###############################################################################
                                 CONTAINS
!###############################################################################

!-------------------------------
 subroutine breed_new_generation (ind, selscheme, gf, qlist, hfile)
!-------------------------------
! produces new offspring, phenotypes and set status 'not alive' to parents
 type(indiv)     :: ind(:)
 type(infosel)   :: selscheme
 type(genome)    :: gf
 type(gcausal)   :: qlist
 integer         :: isires(selscheme%nsires), &
                    idams(selscheme%nsires * selscheme%ndams), &
                    icode(size(ind)), i, j, k, newid, lastid, isire, idam, isex, &
                    nsires, ndams
 character       :: hfile*(*)
 real(r8),allocatable :: work(:,:)
 nsires = selscheme%nsires
 ndams  = selscheme%ndams

 !--> selected individuals
 isires = pack(ind%id, ind%alive .and. ind%sel .and. ind%sex==1)
 idams  = pack(ind%id, ind%alive .and. ind%sel .and. ind%sex==2)

 !--> assortative or random mating
 if (selscheme%assortative==0) then
    call random_permu(idams)
 else
    allocate(work(nsires,2))
    work(:,1) = (/(i, i=1,nsires)/)
    work(:,2) = ind(isires)%ebv(2) !################# ULL: i need to set appropriate ebv
    call sortmat2(work,2)
    isires = int(work(:,1))
    deallocate(work)
    allocate(work(ndams,2))
    work(:,1) = (/(i, i=1,ndams)/)
    work(:,2) = ind(idams)%ebv(2) !################# ULL: i need to set appropriate ebv
    call sortmat2(work,2)
    idams = int(work(:,1))
    if(selscheme%assortative < 0) idams = int((/(work(i,1),i=ndams,1,-1)/))
    deallocate(work)
 endif

 !--> ULL: for the future need to distinguish btw current id and maximum id,
 lastid = maxval(ind%id)
 newid  = lastid
 do i=1, selscheme%nsires
    isire = isires(i)
    do j=1, selscheme%ndams
       idam = idams(j)
       do k=1, selscheme%noff
          newid = newid+1
          isex  = mod(newid,2)+1 !--> equal no. of males and females
          call mate (newid,isex,gf,ind(newid),ind(isire),ind(idam))
          call get_y(ind(newid),qlist)
       enddo
    enddo
 enddo

 !--> kill previous generation
 do i=1, lastid
    if(ind(i)%alive) call kill(ind(i))
 enddo
!--------------
 end subroutine
!--------------


!---------------------
 subroutine select_ind (ind, selscheme)
!---------------------
! among alive, sets to status selected or not, we need to select nsires & nsires*ndams samples
!
 real, parameter :: ebv0=-99999
 type(indiv)     :: ind(:)
 type(infosel)   :: selscheme
 integer         :: nsires, ndams, nind, i, isel(selscheme%nsires * selscheme%ndams)
 real(r8)        :: work(size(ind),2)
 nsires = selscheme%nsires
 ndams  = selscheme%nsires * selscheme%ndams
 nind   = size(ind)

 !--> select males
 work(:,1) = (/(i, i=1,nind)/)
 work(:,2) = ind%ebv(2) !################# ULL: i need to set appropriate ebv
 !--> discard not available individuals or from the other sex
 where(.not.ind%alive .and. ind%sex==2) work(:,2)=ebv0
 call sortmat2(work,2)                   !--> sort to select
 isel(1:nsires) = int(work(1:nsires,1))  !--> select males
 ind(isel(1:nsires))%sel = .true.

 !--> select females
 work(:,1) = (/(i, i=1,nind)/)
 work(:,2) = ind%ebv(2)  !################# ULL: i need to set appropriate ebv
 where(.not.ind%alive .and. ind%sex==1) work(:,2)=ebv0
 call sortmat2(work,2)
 isel(1:ndams) = int(work(1:ndams,1))
 ind(isel(1:ndams))%sel = .true.
!--------------
 end subroutine
!--------------


!--------------------------
 subroutine sample_new_snps (qlist,gf,inds)
!--------------------------
! for each qtl, generates position, new genotypes given f & r2, and update gf
 type(genome)  :: gf
 type(indiv)   :: inds(:)
 type(gcausal) :: qlist
 integer       :: i, iq, nind, ipos, ic
 real          :: f, ewens(2*size(inds)-1)
 integer, allocatable :: g(:), g0(:)

 nind=size(inds)
 allocate(g(2*nind), g0(2*nind))

 do iq=1, qlist%nqtl

    !--> sample f
    select case (qlist%simqtl%f)
      case('u','U')
        f=qlist%simqtl%b(1) + rxnd()*(qlist%simqtl%b(2)-qlist%simqtl%b(1))
      case('n','N')
        ewens=ewens_p(2*nind)
        call random_loaded(i,real(ewens,r8))
        f = max(0.005,i/real(2*nind))
      case default
        STOP 'Unknown option in simulating new snp freq' 
    end select

    !--> sample genotypes
    ic=qlist%qtl(iq)%chr
    ipos=qlist%qtl(iq)%ipos
    do i=1, 2*nind,2
       g0(i:i+1)=inds((i-1)/2+1)%g%ichr(ic)%snp(ipos,:)
    enddo
    call simulate_genotype(g,g0,qlist%simqtl%r2,f)

    !--> update inds & gf, converts vector into matrix nind,2
    call insert_genotype(reshape(g,(/nind,2/),order=(/2,1/)),gf,qlist%qtl(iq),inds)

 enddo
 deallocate(g,g0)
!--------------
 end subroutine
!--------------

!--------------------------
 subroutine insert_genotype (genotype,gf,qlocus,inds)
!--------------------------
! insert new genotype, requires changing gfeatures & ind%g & qtl%ipos
 type(indiv)  :: inds(:)
 type(genome) :: gf
 type(qtl)    :: qlocus
 integer      :: genotype(:,:), i, ic, ipos, nsnp
 integer(i8), allocatable :: pos(:)
 integer, allocatable     :: g(:,:)

 ic   = qlocus%chr
 ipos = qlocus%ipos
 nsnp = gf%ichr(ic)%nsnp

 !--> this makes it back the qtl position by one marker if the last one
 if(qlocus%ipos==gf%ichr(ic)%nsnp) qlocus%ipos=qlocus%ipos-1

 !--> update map info
 allocate(pos(nsnp+1))
 pos(1:ipos) = gf%ichr(ic)%pos(1:ipos)
 !--> new pos in the middle
 pos(ipos+1) = (gf%ichr(ic)%pos(ipos) + gf%ichr(ic)%pos(ipos+1)) / 2
 pos(ipos+2:nsnp+1) = gf%ichr(ic)%pos(ipos+1:nsnp)
 deallocate(gf%ichr(ic)%pos)
 gf%ichr(ic)%nsnp = gf%ichr(ic)%nsnp + 1
 allocate(gf%ichr(ic)%pos(gf%ichr(ic)%nsnp))
 gf%ichr(ic)%pos(:) = pos
 deallocate(pos)

 !--> update qtl info (next marker)
 qlocus%ipos = qlocus%ipos+1

 !--> insert genotype data
 allocate(g(nsnp+1,2))
 do i=1, size(inds)
     g(1:ipos,:) = inds(i)%g%ichr(ic)%snp(1:ipos,:)
     g(ipos+1,:) = genotype(i,:)
     g(ipos+2:nsnp+1,:) = inds(i)%g%ichr(ic)%snp(ipos+1:nsnp,:)
     deallocate(inds(i)%g%ichr(ic)%snp)
     allocate(inds(i)%g%ichr(ic)%snp(nsnp+1,2))
     inds(i)%g%ichr(ic)%nsnp = size(g)
     inds(i)%g%ichr(ic)%snp = g
 enddo
 deallocate(g)
!--------------
 end subroutine
!--------------

!-------------------
 subroutine xval_ebv (criterion, rhox, ind, qlist, gf, selscheme, hfile, h2)
!-------------------
! performs xvalidation
! accomplished by setting temporarily y to missing
 type(indiv)   :: ind(:)
 type(gcausal) :: qlist
 type(infosel) :: selscheme
 type(genome)  :: gf
 character     :: hfile*(*), criterion*(*)
 integer       :: i, irep, nval, ids(size(ind)), n
 real(r8)      :: h2, rhox, irho, ytemp(size(ind)), ebv(size(ind))
 integer, allocatable :: ixds(:)
 !nval  = size(ind) * selscheme%pxval !--> nind used in validation set
 ytemp = ind(:)%y
 !--> order of individuals
 ids   = (/(i, i=1,size(ids))/)
 !--> number of potentially deleted inds
 n = size(pack(ids, (ind%id>=selscheme%idx(1) .and. ind%id<=selscheme%idx(2))))
 allocate(ixds(n))
 ixds = pack(ids, (ind%id>=selscheme%idx(1) .and. ind%id<=selscheme%idx(2)))
 nval = n * selscheme%pxval
 if(nval<1)          STOP 'No individual removed for xvalidation'
 if(nval==size(ind)) STOP 'No individual left for xvalidation'
 rhox  = 0

 do irep=1, selscheme%nxval
    call random_permu(ixds)
    !--> remove phenotype for validation set
    ind(ixds(1:nval))%y = missing
    !PRINT*, size(ind%y), Ind%y
    call get_ebv (criterion, irho, ind, qlist, gf, selscheme, hfile, h2, ebv)
    rhox = rhox + correlation(ind(ixds(1:nval))%tbv, ebv(ixds(1:nval)))
    !print*, 'xval corr', criterion, nval, ids(1:nval), correlation(ind(ids(1:nval))%tbv, ebv(ids(1:nval)))
    !print*, 'rest corr', correlation(ind(ids(nval+1:))%ebv, ind(ids(nval+1:))%tbv)
    !--> restore phenotype
    ind(ixds(1:nval))%y = ytemp(ixds(1:nval))
 enddo
 rhox = rhox / selscheme%nxval
 !PRINT*, IXDS
 deallocate(ixds)
!--------------
 end subroutine
!--------------

!------------------
 subroutine get_ebv (criterion, rho, ind, qlist, gf, selscheme, hfile, h2, ebv, solfile, printsol)
!------------------
! allows for errors in seq (selscheme%perror)
! hfile should contain written data, not used yet
! except in blup, data can be missing
! if iosol, prints snp solutions with coordinates
 optional      :: solfile, printsol
 type(indiv)   :: ind(:)
 type(gcausal) :: qlist
 type(infosel) :: selscheme
 type(genome)  :: gf
 character             :: hfile*(*), criterion*(*), solfile*(*)
 integer               :: iosol=77, nind, nsnp, nchr, i, ic, j, ik, k, ipos, itrace, nB
 real                  :: p_err(3)
 real(r8)              :: h2, ve, ymean, rho, ebv(:)
 real(r8), allocatable :: sol(:), X(:,:), Ainv(:,:)
 integer,  allocatable :: ped(:,:)
 logical               :: printsol, prints
 
 prints=.false.
 if(present(printsol)) prints=printsol
 if (present(solfile) .and. prints) then
    open(iosol,file=solfile,access='append')
    write(iosol,'(a)') '#'
 endif

 nind = size(ind)
 nchr = gf%nchr

 !--> computes ve
 ve = sqrt(variance(ind%y,ind%y.ne.missing))

 !--> phenotypic selection
 !print*, 'y  ',real(ind(:)%y)
 !print*, 'tbv',real(ind(:)%tbv)

 if (criterion == 'y') then
    ebv(:) = ind(:)%y
    !--> if missing, ebv replaced by mean
    where(ind%y==missing) ebv = mmean(pack(ind%y, ind%y.ne.missing))
    rho = correlation(ebv,ind(:)%tbv)
    !print*,'rho bv y',rho
    !print*

 !ULL: I need to consider the true pedigree, not only that in selscheme%pedig
 !--> blup
 elseif (criterion == 'blup') then
    allocate(Ainv(nind,nind), X(nind,nind+1), sol(nind+1), ped(nind,3))
    X = 0.
    do i=1, nind
       !--> accounts for missing
       if(ind(i)%y .ne. missing) then
          X(i,i+1) = 1
          X(i,1)   = 1. !--> mean
       endif
       !--> generates pedigree
       ped(i,1)   = ind(i)%id
       ped(i,2:3) = ind(i)%parents
    enddo
    !--> recode pedigree
    ped  = recodeped(ped)
    !--> do inverse
    call do_Ainv(Ainv, ped)
    call pcgrua (sol, X, ind(:)%y, Ainv, h2*ve, ve, miss=missing)
    ebv = sol(2:nind+1)
    !print*,'blup ebv',real(ebv)
    rho = correlation(ebv,ind(:)%tbv)
    !print*,'rho bv blup',rho
    deallocate(Ainv, X, sol, ped)

 !--> sequence based
 elseif (criterion == 'gsseq') then !--> no variance estimates, chip or seq
    nsnp = sum(gf%ichr(:)%nsnp) !--> total number of snps
    allocate(X(nind,nsnp+1), sol(nsnp+1))
    X(:,1) = 1. !--> mean
    do i=1, size(ind)
       X(i,2:nsnp+1) = (/(ind(i)%g%ichr(ic)%snp(:,1)+ind(i)%g%ichr(ic)%snp(:,2), ic=1, nchr)/)
    enddo

    !--> generate errors, trace = 3 if all diag els are 1
    itrace = sum(selscheme%s_err, reshape( (/((i==j,i=1,3),j=1,3)/), (/3,3/) ) ) + &
             sum(selscheme%i_err, reshape( (/((i==j,i=1,3),j=1,3)/), (/3,3/) ) )
    if(itrace .ne. 6) then
       call do_erros(X(:,2:), selscheme%s_err, selscheme%kmin)
       call do_erros(X(:,2:), selscheme%i_err)
    endif

    call solveSNPsub (ebv, sol, h2*ve, ve, X, ind(:)%y, miss=missing, nonl=selscheme%nlinear, nB=selscheme%nlociB)

    rho = correlation(ebv,ind(:)%tbv)
    if(prints) then
       ik=0
       do ic=1, gf%nchr
          do k=1, gf%ichr(ic)%nsnp
             ik=ik+1
             if(mean(X(:,ik+1))>1d-5 .and. mean(X(:,ik+1))<2.) &
             write(iosol,*) ic, k, gf%ichr(ic)%pos(k), real(sol(1+ik)), real(mean(X(:,ik+1))*0.5)
          enddo
       enddo
    endif
    !print*,'rho bv seq', rho
    deallocate(X, sol)

 !--> array based
 elseif (criterion .eq. 'gschip') then !--> no variance estimates, chip or seq
    nsnp = sum(gf%ichr(:)%nchip) !--> total number of snps
    allocate(X(nind,nsnp+1), sol(nsnp+1))
    X = 0
    X(:,1) = 1. !--> mean
    do i=1, size(ind)
       ik=1
       do ic=1, nchr
          do k=1, gf%ichr(ic)%nchip
             ik=ik+1
             X(i,ik) = sum(ind(i)%g%ichr(ic)%snp(gf%ichr(ic)%chip(k),1:2))
          enddo
       enddo
   !   impossible with ifort
   !    X(i,2:nsnp+1) = (/(ind(i)%g%ichr(ic)%snp(gf%ichr(ic)%chip(1:gf%ichr(ic)%nchip),2), ic=1, nchr)/)
   !    X(i,2:) = (/(ind(i)%g%ichr(ic)%snp(gf%ichr(ic)%chip(:),1) + &
   !                 ind(i)%g%ichr(ic)%snp(gf%ichr(ic)%chip(:),2), ic=1, nchr)/)
    enddo

    !--> generate genotyping errors,
    !    itrace = 3 if all els in diagonal are 1 and then no errors
    itrace = sum(selscheme%g_err, reshape( (/((i==j,i=1,3),j=1,3)/), (/3,3/) ) )
    if(itrace .ne. 3) then
       call do_erros(X(:,2:), selscheme%g_err)
    endif

    call solveSNPsub (ebv, sol, h2*ve, ve, X, ind(:)%y, miss=missing, nonl=selscheme%nlinear, nB=selscheme%nlociB)
    rho = correlation(ebv,ind(:)%tbv)
    if(prints) then
       ik=0
       do ic=1, gf%nchr
          do k=1, gf%ichr(ic)%nchip
             ik=ik+1
             if(mean(X(:,ik+1))>1d-5 .and. mean(X(:,ik+1))<2.) &
             write(iosol,*) ic, k, gf%ichr(ic)%pos(gf%ichr(ic)%chip(k)), real(sol(1+ik)), real(mean(X(:,ik+1))*0.5)
          enddo
       enddo
    endif

    !print*,'chip ebv',real(ind(:)%ebv)
    !print*,'rho bv chip', rho
    deallocate(X, sol)

 !--> causal mutations based
 elseif (criterion .eq. 'gsqtl') then !--> no variance estimates, chip or seq
    nsnp = gf%nqtl !--> total number of snps
    allocate(X(nind,nsnp+1), sol(nsnp+1))
    X(:,1) = 1. !--> mean
    do i=1, size(ind)
       X(i,2:nsnp+1) = ind(i)%g_qtl(:)
    enddo
    call solveSNPsub (ebv, sol, h2*ve, ve, X, ind(:)%y, miss=missing, nonl=selscheme%nlinear, nB=gf%nqtl)
    rho = correlation(ebv,ind(:)%tbv)
    if(prints) then
       do i=1, gf%nqtl
          ic   = qlist%qtl(i)%chr
          ipos = qlist%qtl(i)%ipos
          write(iosol,*) ic, i, gf%ichr(ic)%pos(ipos), real(sol(1+i)), real(mean(X(:,i+1))*0.5)
       enddo
    endif
    !print*,'rho bv qtl', rho; print*
    deallocate(X, sol)
 endif
 
 if (present(solfile)) close (iosol)
!--------------
 end subroutine
!--------------

!-------------------
 subroutine do_erros (X, p, cmin)
!-------------------
! add errors
 integer, optional :: cmin
 real(r8) :: X(:,:), p(3,3)
 integer  :: i, j, ig, ige, nind, nsnp
 nsnp = size(X,dim=2)
 nind = size(X,dim=1)

 do j=1, nsnp
    do i=1, nind
       ig = int(X(i,j))+1
       call random_loaded(ige, p(ig,:))
       !if(ig.ne.ige) print*, ig, ige
       X(i,j) = ige-1
    enddo
    !--> min allele count required
    if(present(cmin)) then
       if (sum(X(:,j)) < cmin .or. sum(X(:,j)) > nind-cmin) X(:,j)=0
    endif
 enddo
!--------------
 end subroutine
!--------------

!--------------------
 subroutine print_ebv (doit,ind)
!--------------------
! prints y, tbv and ebv's
 type(indiv)  :: ind(:)
 type(dothis) :: doit
 integer      :: i, ioebv=11
 
 open(ioebv,file=doit%ebvfile,access='append')
 
 write(ioebv,'(a)',advance='no') '#   Id         Y       TBV'
 if(doit%blup) write(ioebv,'(a)',advance='no') '    BLUP'
 if(doit%chip) write(ioebv,'(a)',advance='no') '    CHIP'
 if(doit%blup) write(ioebv,'(a)',advance='no') '     SEQ'
 if(doit%blup) write(ioebv,'(a)',advance='no') '     QTL'
 write(ioebv,*)
 
 do i=1, size(ind)
 write(ioebv,'(i6,6f10.3)',advance='no') ind(i)%id, ind(i)%y, ind(i)%tbv
    if(doit%blup) write(ioebv,'(f8.3)',advance='no') ind(i)%ebv(1)
    if(doit%chip) write(ioebv,'(f8.3)',advance='no') ind(i)%ebv(2)
    if(doit%blup) write(ioebv,'(f8.3)',advance='no') ind(i)%ebv(3)
    if(doit%blup) write(ioebv,'(f8.3)',advance='no') ind(i)%ebv(4)
    write(ioebv,*)
 enddo
 
 close(ioebv)
!--------------
 end subroutine
!--------------


!---------------------
 subroutine print_data (option, doit, ind, gfeatures, qlist, raw)
!---------------------
! prints data according to Legarra's program solveSNP or plink format
! id, y, mean, genotypes_ coded_012
! i5,f15.5,f5.0,1x,10000000i1
! option can be 'chip', 'seq' or 'qtl'
 type(dothis) :: doit
 type(indiv)  :: ind(:)
 type(genome) :: gfeatures
 type(gcausal):: qlist
 integer(i8)  :: pos
 character    :: option*(*), name*30
 integer      :: iout=54, iomap=55, i, ic, ij, isnp, nf, iff
 integer, allocatable :: z(:)
 logical      :: plink=.true., raw
 optional     :: qlist

 !--> if features defined
 if(qlist%fdefined) allocate(z(size(qlist%varf)+1))
 
 !--> open plink.ped files
 select case(option)
   case('chip')
     open(iout,file=doit%plinkfile(1),access='append')
     write(iout,'(a)') '#'
   case('seq')
     open(iout,file=doit%plinkfile(3),access='append')
     write(iout,'(a)') '#'
   case('qtl')
     open(iout,file=doit%plinkfile(5),access='append')
     write(iout,'(a)') '#'
end select

 do i=1, size(ind)
 
    if(plink) then
       write(iout,'(i2,3i6,i2,f15.5,1x)',advance='no') &
                  1, ind(i)%id, ind(i)%parents(:), ind(i)%sex, ind(i)%y
    else
       write(iout,'(i5,f15.5,i5,1x)',advance='no') ind(i)%id, ind(i)%y, 1
    endif

    select case(option)

       !--> print all snps
       case ('seq')
         do ic=1, gfeatures%nchr
            do isnp=1, gfeatures%ichr(ic)%nsnp
               if(.not. raw) then
                  write(iout,'(2i2)',advance='no') 1+ind(i)%g%ichr(ic)%snp(isnp,:)
               else
                  write(iout,'(i2)',advance='no') sum(ind(i)%g%ichr(ic)%snp(isnp,:))
               endif
            enddo
         enddo

       !--> print ascertained snps
       case ('chip')
         do ic=1, gfeatures%nchr
            do ij=1, gfeatures%ichr(ic)%nchip
               isnp = gfeatures%ichr(ic)%chip(ij) !--> snp order
               if(.not. raw) then
                  write(iout,'(2i2)',advance='no') 1+ind(i)%g%ichr(ic)%snp(isnp,:)
               else
                  write(iout,'(i2)',advance='no') sum(ind(i)%g%ichr(ic)%snp(isnp,:))
               endif
            enddo
         enddo

       !--> print causal snps
       case ('qtl')
         if(present(qlist)) then
            do ij=1, qlist%nqtl
               ic   = qlist%qtl(ij)%chr
               isnp = qlist%qtl(ij)%ipos
               if(.not. raw) then
                 write(iout,'(2i2)',advance='no') 1+ind(i)%g%ichr(ic)%snp(isnp,:)
               else
                  write(iout,'(i2)',advance='no') sum(ind(i)%g%ichr(ic)%snp(isnp,:))
               endif
            enddo
         else
            STOP 'qlist must be specified to print causal loci'
         endif

       !--> a valid option must be specified
       case default
         STOP 'Wrong option in print_data'
    end select
    write(iout,*) !--> next line
 enddo
 close(iout)
 
 !--> print map files
 if(plink) then
     select case(option)
       case ('seq')
         open(iomap,file=doit%plinkfile(4),access='append')
         write(iomap,'(a)') '#'
         do ic=1, gfeatures%nchr
            do isnp=1, gfeatures%ichr(ic)%nsnp
               call namesnp(name,ic,isnp)
               if(qlist%fdefined) then
                  !--> gets Z incidence matrix for that marker
                  call do_z(z,gfeatures%ichr(ic)%pos(isnp),ic,qlist%features)
                  write(iomap,'(i4,2a,i2,i8,10000i2)') ic, ' ',trim(name), 0, gfeatures%ichr(ic)%pos(isnp),z
               else
                  write(iomap,'(i4,2a,i2,i8,10000i2)') ic, ' ',trim(name), 0, gfeatures%ichr(ic)%pos(isnp),z
               endif
            enddo
         enddo
         close(iomap)

       !--> print ascertained snps
       case ('chip')
         open(iomap,file=doit%plinkfile(2),access='append')
         write(iomap,'(a)') '#'
         do ic=1, gfeatures%nchr
            do ij=1, gfeatures%ichr(ic)%nchip
               isnp = gfeatures%ichr(ic)%chip(ij)
               call namesnp(name,ic,isnp)
               if(qlist%fdefined) then
                  call do_z(z,gfeatures%ichr(ic)%pos(isnp),ic,qlist%features)
                  write(iomap,'(i4,2a,i2,i8,100000i2)') ic,' ', trim(name), 0, gfeatures%ichr(ic)%pos(isnp),z
               else
                 write(iomap,'(i4,2a,i2,i8,100000i2)') ic, ' ',trim(name), 0, gfeatures%ichr(ic)%pos(isnp)
               endif
            enddo
         enddo
         close(iomap)

       !--> print causal snps
       case ('qtl')
         open(iomap,file=doit%plinkfile(6),access='append')
         write(iomap,'(a)') '#'
         do ij=1, qlist%nqtl
             ic   = qlist%qtl(ij)%chr
             isnp = qlist%qtl(ij)%ipos
             call namesnp(name,ic,isnp)
             if(qlist%fdefined) then
                call do_z(z,gfeatures%ichr(ic)%pos(isnp),ic,qlist%features)
                write(iomap,'(i4,2a,i2,i8,10000i2)') ic, ' ',trim(name), 0, gfeatures%ichr(ic)%pos(isnp),z
             else
                write(iomap,'(i4,2a,i2,i8,10000i2)') ic, ' ',trim(name), 0, gfeatures%ichr(ic)%pos(isnp)
             endif
         enddo
         close(iomap)
    end select
 endif
 if(allocated(z)) deallocate(z)
!--------------
 end subroutine
!--------------

!------------------
 subroutine namesnp (name,i,j)
!------------------
 integer :: i,j
 character :: name*(*), a*20,b*20
 write(a,*) i
 write(b,*) j
 name = trim(adjustl(a))//'_'//trim(adjustl(b))
!--------------
 end subroutine
!--------------

!----------------------
 subroutine print_stats (inds, gf, qlist, mschip, msseq, living)
!----------------------
! print_stats for alive individuals
! varianza geneticas, heterocigosidad, distribucion de frecuencias alelicas
! call print_stats('gs.stat', ind, gfeatures, qlist)
 logical, optional   :: mschip, msseq, living
 type(indiv)         :: inds(:)
 type(genome)        :: gf
 type(gcausal)       :: qlist
 integer             :: i, ic, iq, isnp, j, ij, nalive
 real, allocatable   :: f(:)
 real                :: a, va(size(qlist%qtl))
 !logical :: alive

 do iq=1, qlist%nqtl
    ic   = qlist%qtl(iq)%chr
    isnp = qlist%qtl(iq)%ipos
    qlist%qtl(iq)%f = 0
    nalive=0
    do i=1, size(inds)
       if(inds(i)%alive .and. associated(inds(i)%g%ichr)) then
          qlist%qtl(iq)%f = qlist%qtl(iq)%f + 0.5*sum(inds(i)%g%ichr(ic)%snp(isnp,:))
          nalive=nalive+1
       endif
    enddo
    qlist%qtl(iq)%f = qlist%qtl(iq)%f / nalive
    a = qlist%qtl(iq)%a + (1.-2*qlist%qtl(iq)%f) * qlist%qtl(iq)%d
    va(iq) = 2.*qlist%qtl(iq)%f*(1.-qlist%qtl(iq)%f) * qlist%qtl(iq)%a**2
 enddo
 
 print*
 print'(a)', 'STATS'
 print'(a,i5)', ' N alive', nalive
 print'(a,i5)', ' N total', size(inds)
 print'(a,2f10.4)', ' Ymean Ysd:   ', mmean(inds%y,mask=inds%alive), sqrt(variance(inds%y,mask=inds%alive))
 print'(a,2f10.4)', ' Gmean Gsd:   ', mmean(inds%tbv,mask=inds%alive), sqrt(variance(inds%tbv,mask=inds%alive))
 print'(a,2f10.4)', ' Observed h2:', variance(inds%tbv,mask=inds%alive) / variance(inds%y,mask=inds%alive)
 print'(a,100000f6.3)', ' QTL freqs:', qlist%qtl(:)%f
 print'(a,100000f6.3)', ' QTL h2:   ', va(:) / (sum(va) + qlist%ve)
 print*
 !print*, 'print stats capped'

RETURN

 !--> freqs by chip
 allocate(f(sum(gf%ichr(:)%nchip))); f=0; ij=0
 print*, 'SNP array freqs:',size(f)
 do ic=1, gf%nchr
    do j=1, gf%ichr(ic)%nchip
       isnp = gf%ichr(ic)%chip(j)
       ij = ij+1
       do i=1, size(inds)
          if(inds(i)%alive)  f(ij) = f(ij) + 0.5*sum(inds(i)%g%ichr(ic)%snp(isnp,:))
       enddo
       f(ij) = f(ij)/count(inds%alive)
       write(*,'(f6.3)',advance='no') f(ij)
    enddo
    print*
 enddo
 print*, 'N. fixed:', count(f==0. .or. f==1.)
 print*
 deallocate(f)

 !--> freqs by seq
 allocate(f(sum(gf%ichr(:)%nsnp))); f=0; ij=0
 print*, 'SNP freqs:',size(f)
 do ic=1, gf%nchr
    do j=1, gf%ichr(ic)%nsnp
       ij=ij+1
       do i=1, size(inds)
          if(inds(i)%alive)  f(ij) = f(ij) + 0.5*sum(inds(i)%g%ichr(ic)%snp(j,:))
       enddo
       f(ij) = f(ij)/count(inds%alive)
       write(*,'(f5.2)',advance='no') f(ij)
    enddo
    print*
 enddo
 print*, 'N. fixed:', count(f==0. .or. f==1.)
 deallocate(f)
!--------------
 end subroutine
!--------------


!-------------------
 subroutine read_par (parfile, qlist, chip, selscheme, gfeatures, mscommand, msfile, &
                      n_iter, out_def, ms_def, snp_def, seed_def, seed, inplink, doit)
!-------------------
!------------------------------------
! reads variables and init main types
!------------------------------------
 integer        :: iopar=87, nchr=0, nqtl=0, ngen, nsires, ndams, noff, i, ios,   &
                   asc_ind(2)=0, qtl_ind(2)=0, seed(:), nxval, n_iter, nreg, &
                   nindms, idx(2)=0, kmin=1, nf, n, nlociB, kill(2)=0
 character      :: parfile*(*), msfile*(*), mscommand*(*), c*30, criterion*6, &
                   pedfile*40=' ', snpfile*40=' ', regfile*40=' ', mapfile*40 = ' ',&
                   temp*4='temp', ffile*40=' ', xc(10)*5, qtlregfile*40=' '
 real           :: h2=0., cM2Mb=1., maf=0., p=1, pxval=0.1, sign_qtl=0.5, perr(3)=0, &
                   qfreq(2), py=0, x(size(xc))
 type(dothis)   :: doit
 type(gcausal)  :: qlist
 type(infochip) :: chip
 type(infosel)  :: selscheme
 type(genome)   :: gfeatures
 type(qdensity) :: qdista, qdistd, qdistva, qdistvd, fdist
 type(simu_qtl) :: simqtl
 real, allocatable        :: va(:), vd(:), a(:), d(:), var_f(:)
 integer, allocatable     :: ichr(:), ipos(:)
 integer(i8), allocatable :: chr_lengths(:), qtl_regs(:,:)
 logical                  :: ex, init_eff, init_feat, use_ascertained, use_qtl_inds, adjust_ve, &
                             out_def, ms_def, snp_def, seed_def, qtl_pos_def, axa, &
                             inplink,  do_ms
 character(len=1) :: nonl                             

 init_eff        = .false.
 init_feat       = .false.
 use_ascertained = .false.
 adjust_ve       = .false.
 qtl_pos_def     = .false.
 axa             = .false.
 nonl            = '0'
 do_ms           = .false.
 kmin            = selscheme%kmin
 qfreq           = [0.,1.]
 sign_qtl        = 0.5
 qtl_ind         = 0

 inquire(file=parfile,exist=ex)
 if(.not.ex .or. wc(parfile)==0) STOP 'Parameter file does not seem to exist; for help: ms2gs -h '
   
 !--> creates a temp parameter file w/o comments (# or !) nor blank lines
 call system ('grep -v ^\# ' // parfile // '| grep -v ^$ | grep -v ^! >' // temp)
 open(iopar,file=temp)
 do
    read(iopar,*,iostat=ios) c
    if(ios.ne.0) EXIT
    select case (c)
    case('NITER') !--> reads only if not defined in command line
      if(n_iter==0) read(iopar,*) n_iter
    case('NOBLUP')
      doit%blup=.false. 
    case('NOCHIP')
      doit%chip=.false.
    case('NOSEQ')
      doit%seq=.false.
    case('NOCAUSAL')
      doit%qtl=.false.
    case('NOFIT')
      doit%fit=.false.
    case('NOXVAL')
      doit%xval=.false.
    case('MSCOMMAND') !--> overriden by command line -ms option
      read(iopar,'(a)') mscommand
      do_ms=.true.
    case('MSFILE') !--> overriden by command line -ms option
      read(iopar,*) c
      if(.not.ms_def) msfile=c
      if(.not.ms_def .and. wc(msfile)==0) STOP 'msfile seems not to exist'
      do_ms=.true.
    case('PLINKFILE')
      read(iopar,*) msfile
      if(wc(msfile//'.ped')==0) STOP 'Plink ped file does not exist or seems to be empty'
      if(wc(msfile//'.map')==0) STOP 'Plink map file does not exist or seems to be empty'
      inplink=.true.
    case ('PEDFILE')
      read(iopar,*) pedfile
      if(wc(pedfile)==0) STOP 'Pedfile does not exist or seems to be empty'
    case ('SNPFILE') !--> if present, overrides ASCERTAINMENT & SNPREG section
      read(iopar,*) c
      if(.not. snp_def) snpfile=c
    case ('SNPREGFILE') !--> if present, overrides ASCERTAINMENT section
      read(iopar,*) c
      if(.not. snp_def) regfile=c
    case ('MAPFILE')    !--> file with rec rates in cM2Mb units
      read(iopar,*) mapfile
    case ('OUTFILE')    !--> prefix output file
      read(iopar,*) doit%outfile
    case ('PRINT_SOL')
      doit%print_sol = .true.
    case ('PRINT_YG')
      doit%print_yg = .true.
    case ('PRINT_PLINK')
      doit%print_plink = .true.
    case ('PRINT_MS')
      doit%print_ms = .true.
    case ('FEATUREFILE')
      read(iopar,*) ffile
      qlist%fdefined = .true.
    case ('FEATURE_VARIANCE')
      read(iopar,*) nf
      allocate (var_f(nf))
      read(iopar,*) var_f(:)
    case ('INBRED_FOUNDERS')
      selscheme%inbred=.true.
    case ('NCHR')
      read(iopar,*) nchr
      allocate(chr_lengths(nchr))
      chr_lengths=0
    case ('CM2MB')
      read(iopar,*) cM2Mb
    case ('CHR_LENGHTS')
      if(nchr==0) STOP 'N chrs must be defined before chr lengths'
      read(iopar,*) chr_lengths(:)
    case ('BINARY_TRAIT')
      read(iopar,*) py    
    case ('H2')
      read(iopar,*) h2
    case ('NQTL')     
      read(iopar,*) nqtl
      allocate(va(nqtl), vd(nqtl), ichr(nqtl), ipos(nqtl), a(nqtl), d(nqtl))
      va=0; vd=0; ichr=0; a=0; d=0; ipos=0; ichr=0
    case ('QTL_INDS')     
      read(iopar,*) qtl_ind(1:2)
    case ('QTL_SIGN')     
      read(iopar,*) sign_qtl
    case ('QTL_POS')
      if(nqtl==0) STOP 'N QTL must be defined before QTL posns.'
      do i=1, nqtl
         read(iopar,*) ichr(i), ipos(i)
      enddo
      qtl_pos_def = .true.
    case ('QTLREGFILE')
      read(iopar,*) qtlregfile
    case ('SIMULATE_QTL_SNP')
      read(iopar,'(a)') c
      call nums2(c,n,x,xc)
      simqtl%r2=x(1)              !--> average disequilibrium
      simqtl%f=xc(2)(1:1)         !    U or N (uniform or neutral)
      if(n>2) simqtl%b=x(3:4)     !    bounds (U) 
    case ('SIMULATE_QTL_SNP_R2')  !--> average disequilibrium
      read(iopar,*) simqtl%r2
    case ('SIMULATE_QTL_SNP_FNEUTRAL')
      simqtl%f='n'
    case ('SIMULATE_QTL_SNP_FUNIFORM')
      read(iopar,*) simqtl%b(1:2)
      simqtl%f='u'
    case('QTL_FREQ_RANGE')
      read(iopar,*) qfreq(1:2)
    case ('QTL_VA')
      read(iopar,*) va(1:nqtl)
      if(any(va<0)) STOP 'Additive variances must be positive'
    case ('QTL_VD')
      read(iopar,*) vd(1:nqtl)
      if(any(vd<0)) STOP 'Dominant variances must be positive'
    case ('QTL_EFFECT_A')
      read(iopar,*) a(:)
      init_eff = .true.
    case ('QTL_EFFECT_D')
      read(iopar,*) d(:)
      init_eff = .true.
    case ('QTL_DISTRIBUTION_A')
      read(iopar,*) qdista%f, qdista%x, qdista%s
      init_eff = .true.
    case ('QTL_DISTRIBUTION_D')
      read(iopar,*) qdistd%f, qdistd%x, qdistd%s
      init_eff = .true.
    case ('QTL_DISTRIBUTION_VA')
      read(iopar,*) qdistva%f, qdistva%x, qdistva%s
    case ('QTL_DISTRIBUTION_VD')
      read(iopar,*) qdistvd%f, qdistvd%x, qdistvd%s
    case ('AXA', 'EPISTASIS_AXA')
      axa       = .true.
      adjust_ve = .true.
    case ('ADJUST_VE')
      adjust_ve = .true.
    case ('NIND_MS')
      read(iopar,*) nindms
    case ('SCHEME')
      read(iopar,*) criterion, ngen, nsires, ndams, noff
    case ('ASCERTAINMENT_INDS')
      read(iopar,*) asc_ind(1:2)
    case ('ASCERTAINMENT_MAF')
      read(iopar,*) maf
      maf = min(maf,1.-maf)
    case ('ASCERTAINMENT_P')
      read(iopar,*) p
    case ('USE_ASCERTAINED')
      use_ascertained = .true.
    case ('USE_QTL_INDS')
      use_qtl_inds = .true. !-- not used currently
    case ('KILLINDS')   !--> if some ids from pedigree removed
      read(iopar,*) kill(1:2) 
    case ('NXVAL')  !--> % of removed indivs in xval and no. of xvalidations
      read(iopar,*) nxval
      if(nxval>0) doit%xval=.true.
    case ('PXVAL')  !--> % of removed indivs in xval and no. of xvalidations
      read(iopar,*) pxval 
    case ('IDXVAL') !--> % of removed indivs in xval and no. of xvalidations
      read(iopar,*) idx(1:2)
    case ('KMIN')   !--> min allele count
      read(iopar,*) kmin
    case ('P_ERROR_CHIP') !--> genotyping error
      read(iopar,*) perr(1)
    case ('P_ERROR_NGS')  !--> base sequencing error
      read(iopar,*) perr(2)
    case ('P_ERROR_IMP')  !--> imputation error
      read(iopar,*) perr(3)
    case ('NONLINEARA')
      nonl = 'A'
    case ('NONLINEARB')
      nonl = 'B'
      read(iopar,*) nlociB
    case ('SEED')
      if(.not.seed_defined) then
         read(iopar,*) seed(1)
         seed = seed(1)
      endif
    end select
 enddo
 close (iopar, status='delete')
 
 !--> basic tests
 if(nchr==0) STOP 'NCHR must be defined'
 if(nqtl==0) STOP 'NQTL must be defined'
 if(h2==0)   STOP 'H2 must be defined'
 if(sum(chr_lengths)==0) STOP 'CHR lengths must be > 0'
 if(niter>1 .and. doit%print_sol) &
    print*, 'WARNING: print_sol means that all solutions for every iterate are printed in the same files'
 if(niter>1 .and. doit%print_plink) &
    print*, 'WARNING: print_plink means that all marker info for every iterate are printed in the same files'

 if(inplink .and. (do_ms .or. ms_def)) &
    STOP 'ms command and read_plink cannot be both specified'

 if( sum(qtl_ind)==0 ) then
    qtl_ind(1)=1
    print*, 'WARNING: No QTL_INDS section, all base population considered for qtl parameters'
 endif
 
 if( sum(asc_ind)==0 .and. doit%chip) then
    asc_ind(1)=1
    print*, 'WARNING: No ASCERTAINMENT_INDS section, all base population considered for SNP ascertainment'
 endif
 
 if( sum(idx)==0 .and. doit%xval) then
    print*, 'WARNING: No IDXVAL section, all non base inds considered for crossvalidation'
 endif
 
 !--> the whole genome if not specified otherwise
 if(qtlregfile /= ' ') then
    nreg = wc(qtlregfile)
    if(nreg==0) STOP 'QTLREGFILE empty'
    allocate(qtl_regs(nreg,3))
    open(iopar,file=qtlregfile)
    do i=1, nreg
       read(iopar,*) qtl_regs(i,:)
       if(qtl_regs(i,3)<=qtl_regs(i,2)) STOP 'Wrong qtl region coordinates'
       if(qtl_regs(i,1)>nchr) STOP 'Wrong chr in qtl region coordinates'
    enddo
    close(iopar)
 else
    allocate(qtl_regs(nchr,3))
    do i=1, nchr
       qtl_regs(i,1) = i
       qtl_regs(i,2) = 1
       qtl_regs(i,3) = chr_lengths(i)
    enddo
 endif

 !--> minimum iter=1
 n_iter = max(1,n_iter)

 !--> init genome: only nchr, lengths, xover ratio and nqtl
 call init_genome(gfeatures, mapfile=mapfile, nchr=nchr, chr_lengths=chr_lengths, cM2Mb=cM2Mb, nqtl=nqtl)

 !--> QTL effects or variances are sampled if specified
 if(qdista%f  .ne. ' ') call sample_effect(a, qdista)
 if(qdistd%f  .ne. ' ') call sample_effect(d, qdistd)
 if(qdistva%f .ne. ' ') then
    if(init_eff) STOP 'ULL: Vars cannot be defined if qtl effects are initialized'
    call sample_effect(va, qdistva)
 endif
 if(qdistvd%f .ne. ' ') then
    if(init_eff) STOP 'ULL: Vars cannot be defined if qtl effects are initialized'
    call sample_effect(vd, qdistvd)
 endif

 !--> init qtl object
 call init_gcausal (qlist, h2, va, vd, ichr, ipos, qtl_ind, sign_qtl, a, d, &
                    qdista, qdistd, qdistva, qdistvd, qtl_regs, &
                    init=init_eff, adjust=adjust_ve, pos_def=qtl_pos_def, &
                    axa = axa, ffile=ffile, vf=var_f, qfreq=qfreq, py=py, &
                    sq=simqtl)

 !--> init chip & choose snps
 call init_chip (chip, maf, p, snpfile, regfile, asc_ind)

 !--> call init_scheme
 call init_scheme (selscheme, pedfile, criterion, ngen, nsires, ndams, noff, &
                   use_ascertained, pxval, nxval, idx, nindms, perr, kmin, &
                   nonl, nlociB, kill)
                   
 !--> diverse file naming
 if(doit%print_sol) then
    if(doit%chip) then
       doit%solfile(1)=trim(doit%outfile)//'.chip.sol'
       if(wc(doit%solfile(1))>0) call system('rm '//doit%solfile(1))
    endif
    if(doit%seq) then
       doit%solfile(2)=trim(doit%outfile)//'.seq.sol'
       if(wc(doit%solfile(2))>0) call system('rm '//doit%solfile(2))
    endif
    if(doit%qtl) then
       doit%solfile(3)=trim(doit%outfile)//'.qtl.sol'
       if(wc(doit%solfile(3))>0) call system('rm '//doit%solfile(3))
    endif
 endif

 if(doit%print_plink) then
    if(doit%chip) then
       doit%plinkfile(1)=trim(doit%outfile)//'.chip'//'.ped'
       doit%plinkfile(2)=trim(doit%outfile)//'.chip'//'.map'
       if(wc(doit%plinkfile(1))>0) call system('rm '//doit%plinkfile(1))
       if(wc(doit%plinkfile(2))>0) call system('rm '//doit%plinkfile(2))
    endif
    if(doit%seq) then
       doit%plinkfile(3)=trim(doit%outfile)//'.seq'//'.ped'
       doit%plinkfile(4)=trim(doit%outfile)//'.seq'//'.map'
       if(wc(doit%plinkfile(3))>0) call system('rm '//doit%plinkfile(3))
       if(wc(doit%plinkfile(4))>0) call system('rm '//doit%plinkfile(4))
    endif
    if(doit%qtl) then
       doit%plinkfile(5)=trim(doit%outfile)//'.qtl'//'.ped'
       doit%plinkfile(6)=trim(doit%outfile)//'.qtl'//'.map'
       if(wc(doit%plinkfile(5))>0) call system('rm '//doit%plinkfile(5))
       if(wc(doit%plinkfile(6))>0) call system('rm '//doit%plinkfile(6))
    endif
 endif
 
 if(doit%print_yg) then
    doit%ebvfile = trim(doit%outfile)//'.yge'
    doit%fit=.true.
    if(wc(doit%ebvfile)>0) call system('rm '//doit%ebvfile)
 endif
 
 deallocate (a, d, va, ichr, ipos, chr_lengths, qtl_regs)
!--------------
 end subroutine
!--------------

!---------------------
 subroutine read_plink (pedfile, ind, selscheme, gfeatures, chip)
!---------------------
! reads initial genotypes in plink format assumes phased data
! alleles should be coded 1 & 2, and are recoded 0/1
type(indiv)      :: ind(:)
type(genome)     :: gfeatures
type(infosel)    :: selscheme
type(infochip)   :: chip
character        :: pedfile*(*), mapfile*(50), a(6)*20
integer          :: ioms=99, i, j, h, ij, nind0, nsnp
integer(i8), allocatable :: snpdata(:,:)
integer, allocatable :: ix(:)

 mapfile=adjustl(trim(pedfile))//'.map'
 pedfile=adjustl(trim(pedfile))//'.ped'

 nind0 = wc(pedfile)
 nsnp  = wc(mapfile)
 allocate(snpdata(nsnp,2))

 !--> base indivs
 selscheme%nbase = nind0

 !--> read map file
 open(ioms,file=mapfile)
 do i=1, nsnp
    read(ioms,*) snpdata(i,1),a(1:2),snpdata(i,2)
 enddo
 close(ioms)
 if(maxval(snpdata(:,1))>gfeatures%nchr) STOP 'No chrs in plink file is larger than declared'

 print*, 'plink file: nind, nchr, nmarkers read:', nind0, maxval(snpdata(:,1)), nsnp

 do ic=1, gfeatures%nchr
    gfeatures%ichr(ic)%nsnp = 0
    gfeatures%ichr(ic)%nsnp = size(pack(snpdata(:,1),snpdata(:,1)==ic))
    if(associated(gfeatures%ichr(ic)%pos)) deallocate(gfeatures%ichr(ic)%pos)
    allocate (gfeatures%ichr(ic)%pos(gfeatures%ichr(ic)%nsnp))
    gfeatures%ichr(ic)%pos(:) = pack(snpdata(:,2), snpdata(:,1)==ic)

    !--> reassign chr lengths if needed
    if(gfeatures%ichr(ic)%nsnp>0) &
    gfeatures%ichr(ic)%length = max(gfeatures%ichr(ic)%pos(gfeatures%ichr(ic)%nsnp), gfeatures%ichr(ic)%length)

    !--> init ind, allocates memory
    do id=1, nind0
       isex=mod(id,2)+1 !--> equal no. of males and females
       call init_indiv (ind(id), id, isex, 0, 0, gfeatures, ichr=ic)
       if(.not.selscheme%use_ascertained .and. (id<=chip%ind(1) .or. id>=chip%ind(2))) ind(id)%use=.false.
    enddo
 enddo

 !--> now markers are read and assigned to individuals, assume recoding = 1,2 --> 0,1
 open(ioms,file=pedfile)
 do id=1, nind0
   read(ioms,*) a(1:6), ((ind(id)%g%ichr(ic)%snp(i,1:2), i=1,gfeatures%ichr(ic)%nsnp), ic=1,gfeatures%nchr)
   do ic=1, gfeatures%nchr
      ind(id)%g%ichr(ic)%snp(:,:) = ind(id)%g%ichr(ic)%snp(:,:) - 1
      if(any(ind(id)%g%ichr(ic)%snp(:,:)<0) .or. any(ind(id)%g%ichr(ic)%snp(:,:)>1)) &
        STOP 'plink genotypes must be phased & coded 1/2 without missing data'
   enddo
 enddo
 close(ioms)

 deallocate (snpdata)
!--------------
 end subroutine
!--------------

!------------------
 subroutine read_ms (msfile, ind, selscheme, gfeatures, chip)
!------------------
! the length in bases  of all chromosomes is passed on,
! ms positions are scaled and then each snp is assigned to its chr
! read nind, nchrs, nsnp, snp posns
 type(indiv)              :: ind(:)
 type(genome)             :: gfeatures
 type(infosel)            :: selscheme
 type(infochip)           :: chip
 integer                  :: nind0, nseq, nsnp, nchr, ioms=99, ic, id, h, io, isex, hmax
 logical                  :: ex, multims
 character                :: msfile*(*), c*20, cmd*100, xc(50)*20
 integer,     allocatable :: snpchr(:), n_snpchr(:), snp(:)
 integer(i8), allocatable :: snppos(:)
 real(r8),    allocatable :: rpos(:)
 real                     :: q
 nchr = gfeatures%nchr

 inquire(file=msfile,exist=ex)
 if(.not.ex) STOP 'MS file does not seem to exist'
 open(ioms,file=msfile)

 !--> first test whether multi or single ms file
 multims=.false.
 ic=0
 do
    read(ioms,*,iostat=io) c
    if(io.ne.0) EXIT
    if(c(1:8)=='segsites') ic=ic+1
 enddo
 rewind(ioms)
 if (ic>1) multims=.true.

 !--> read nind0=2*nseq, nsp, posns
 read(ioms,'(a)') cmd
 call nums2 (cmd, n, x, xc)
 nseq = int(x(2))
 if(selscheme%inbred) then
    nind0 = nseq
    hmax = 1
 else
    nind0 = nseq/2
    hmax = 2
 endif
 read(ioms,*) !--> skips

 !--> base indivs
 selscheme%nbase = nind0

 !--> each chr in a separate ms container
 if(multims) then
    do ic=1, nchr
       do i=1, 2; read(ioms,*); enddo !--> skips
       read(ioms,*) c, nsnp
       gfeatures%ichr(ic)%nsnp = nsnp
       if(associated(gfeatures%ichr(ic)%pos)) deallocate(gfeatures%ichr(ic)%pos)
       allocate (snp(nsnp),  &
                 rpos(nsnp), &
                 gfeatures%ichr(ic)%pos(nsnp) )
       read(ioms,*) c, rpos(:) !--> read positions scaled 0-1
       gfeatures%ichr(ic)%pos(:) = rpos(:) * gfeatures%ichr(ic)%length

       !--> init ind
       do id=1, nind0
          isex=mod(id,2)+1 !--> equal no. of males and females
          call init_indiv (ind(id), id, isex, 0, 0, gfeatures, ichr=ic, use=.false.)
          if(.not.selscheme%use_ascertained .and. (id<=chip%ind(1) .or. id>=chip%ind(2))) ind(id)%use=.false.
       enddo

       !--> now markers are read and assigned to individuals
       do id=1, nind0; do h=1,hmax
          read(ioms,'(10000000i1)') snp(1:nsnp)
          if(any(snp>1) .or. any(snp<0)) STOP 'ms allows only 0 or 1 as allele id'
          ind(id)%g%ichr(ic)%snp(:,h) = snp(:)
       enddo; enddo
       deallocate (snp, rpos)
    enddo

 !--> all chrs in a single line
 else
    do i=1, 2; read(ioms,*); enddo !--> skips
    read(ioms,*) c, nsnp
    allocate (rpos(nsnp), snp(nsnp), snppos(nsnp), snpchr(nsnp), n_snpchr(nchr))
    read(ioms,*) c, rpos(:) !--> read positions scaled 0-1

    !--> snps and snp pos are assigned to chrs, gfeatures contains chr lengths
    call snp2chr(snpchr, snppos, rpos, gfeatures)
    do ic=1, nchr
       n_snpchr(ic) = count(snpchr==ic)
    enddo

    !--> second step init genome features: # snps per chr and positions
    call init_genome(gfeatures, nsnp_chr=n_snpchr, snp_pos=snppos)

    !--> init ind
    do id=1, nind0
       call init_indiv (ind(id), id, mod(id,2)+1, 0, 0, gfeatures, use=.false.)
       if(.not.selscheme%use_ascertained .and. (id<=chip%ind(1) .or. id>=chip%ind(2))) ind(id)%use=.false.
    enddo

    !--> now markers are read and assigned to individuals
    do id=1, nind0; do h=1,hmax
       read(ioms,'(10000000i1)') snp(1:nsnp)
       if(any(snp>1) .or. any(snp<0)) STOP 'ms allows only 0 or 1 as allele id'
       do ic=1, nchr
          ind(id)%g%ichr(ic)%snp(:,h) = pack(snp, snpchr==ic)
       enddo
    enddo; enddo

    deallocate(rpos, snp, snpchr, snppos, n_snpchr)
 endif

 !--> finnish up and copy haplotype if inbred
 do id=1, nind0
    do ic=1, nchr
       ind(id)%g%ichr(ic)%snp(:,2) = ind(id)%g%ichr(ic)%snp(:,1)
    enddo
 enddo

 close(ioms)
!--------------
 end subroutine
!--------------

!------------------
 subroutine snp2chr (snpchr, snppos, rpos, gfeatures)
!------------------
! return chr and position of every snp according to chr lengths, and # snps per chr
 type(genome) :: gfeatures
 real(r8)     :: rpos(:)
 integer(i8)  :: snppos(:), chrsum(gfeatures%nchr), clengths(gfeatures%nchr), glength
 integer      :: snpchr(:), i, ic, nchr
 nchr=gfeatures%nchr

 !--> cumulative sum
 do ic=1,nchr
    clengths(ic) = gfeatures%ichr(ic)%length
    chrsum(ic)   = sum(clengths(1:ic))
 enddo
 glength = chrsum(nchr)

 !--> CHECKKKK!!! snpchr contains chr for every marker
 snpchr  = 0
 do ic=1,nchr
    where(rpos*glength/chrsum(ic) <= 1.d0 .and. snpchr==0) snpchr = ic
 enddo

 !--> snppos contains pos within chr
 do i=1, size(rpos)
    ic = snpchr(i)
    snppos(i) = rpos(i)*glength
    if(ic>1) snppos(i) = snppos(i) - chrsum(ic-1)
 enddo
!--------------
 end subroutine
!--------------

!------------------------
 subroutine ascertain_snp (gf, chip, ind)
!------------------------
! selects snps according to chip features and stores in gfeatures%chr(ic)%chip
! I basically use maf and % of remaining snps as criteria: chip%maf and chip%p
! I need to sample either by chr or genomewide
 type(indiv)              :: ind(:)
 type(genome)             :: gf
 type(infochip)           :: chip
 integer, allocatable     :: ixpos(:), snp(:,:), ipos(:), ncsnp(:), itpos(:,:)
 integer(i8)              :: bp1, bp2
 real, allocatable        :: f(:)
 real                     :: f1
 integer                  :: i, i1, i2, ic, nsnp, ntsnp, nchip, nind, im, io, ireg, nreg, &
                             isnp, isr, iosnp=122
 nind = size(ind)
    
 !--> read snp list from file
 if(chip%snpfile .ne. ' ') then
    open(iosnp,file=chip%snpfile)
    nsnp = wc(chip%snpfile)
    allocate(snp(nsnp,2))
    do i=1, nsnp
       read(iosnp,*) snp(i,:)
    enddo
    do ic=1, gf%nchr
       nchip = count(snp(:,1)==ic)
       gf%ichr(ic)%nchip = nchip
       if (nchip>0) then
          if(associated(gf%ichr(ic)%chip)) deallocate(gf%ichr(ic)%chip)
          allocate(gf%ichr(ic)%chip(nchip))
          gf%ichr(ic)%chip = pack(snp(:,2), snp(:,1)==ic)
       endif
    enddo
    deallocate(snp)
    close(iosnp)

 !--> chooses snps from regions
 elseif(chip%regfile .ne. ' ') then
    allocate(ipos(maxval(gf%ichr(:)%nsnp)))
    ipos=(/(i, i=1,size(ipos))/)

    nreg = wc(chip%regfile) !--> counts # regions
    gf%ichr(:)%nchip=0
    !--> counts #snp per region
    open(iosnp,file=chip%regfile)
    do ireg=1, nreg
       read(iosnp,*) ic, bp1, bp2
       gf%ichr(ic)%nchip =  gf%ichr(ic)%nchip + &
                            count(gf%ichr(ic)%pos(:) >= bp1 .and. gf%ichr(ic)%pos(:) <= bp2)
    enddo

    do ic=1, gf%nchr
       if(associated(gf%ichr(ic)%chip)) deallocate(gf%ichr(ic)%chip)
       allocate(gf%ichr(ic)%chip( gf%ichr(ic)%nchip ))
    enddo

    rewind(iosnp)
    allocate(ncsnp(gf%nchr))
    ncsnp = 0
    do i=1, nreg
       read(iosnp,*) ic, bp1, bp2
       nsnp = count(gf%ichr(ic)%pos(:) >= bp1 .and. gf%ichr(ic)%pos(:) <= bp2)
       gf%ichr(ic)%chip(ncsnp(ic)+1:ncsnp(ic)+nsnp) &
         = pack(ipos(1:gf%ichr(ic)%nsnp), &
                gf%ichr(ic)%pos(:) >= bp1 .and. gf%ichr(ic)%pos(:) <= bp2)
       ncsnp(ic) = ncsnp(ic) + nsnp
!PRINT*, ic, bp1, bp2, gf%ichr(ic)%nchip, ncsnp(ic)+1, ncsnp(ic)+nsnp
    enddo
    close(iosnp)
    deallocate(ncsnp, ipos)   

    !--> chapuza para anadir maf y p
    if(chip%maf>0) then
       do ic=1, gf%nchr
          do im=1, gf%ichr(ic)%nchip
             isnp = gf%ichr(ic)%chip(im)
             f1=0
             do i=1, nind
                f1 = f1 + sum(ind(i)%g%ichr(ic)%snp(isnp,:))*0.5/nind
             enddo
             f1=min(f1,1.-f1)
             if(f1<chip%maf) gf%ichr(ic)%chip(im)=0
          enddo
       enddo    
    endif
    
    if(chip%p<1) then !--> randomly remove 1-p snps
       do ic=1, gf%nchr
          do im=1, gf%ichr(ic)%nchip
             isnp = gf%ichr(ic)%chip(im)
             if(isnp>0 .and. rxnd()>=chip%p) gf%ichr(ic)%chip(im)=0
          enddo
       enddo   
    endif
    
    !--> now I need to finish up
    do ic=1, gf%nchr 
       if(any(gf%ichr(ic)%chip==0)) then
          allocate(ipos(gf%ichr(ic)%nchip))
          ipos = gf%ichr(ic)%chip
          gf%ichr(ic)%nchip = count(gf%ichr(ic)%chip>0)
          deallocate(gf%ichr(ic)%chip)
          if(gf%ichr(ic)%nchip>0) then
             allocate(gf%ichr(ic)%chip(gf%ichr(ic)%nchip))
             gf%ichr(ic)%chip = pack(ipos,ipos>0)
          endif
          deallocate(ipos)
       endif
    enddo   
 
 !--> ascertain genomewide from parameters maf & p
 else
    ntsnp = sum(gf%ichr(:)%nsnp)
    !--> indices for all markers
    allocate(itpos(ntsnp,3))
    itpos(:,3) =(/(i,i=1,ntsnp)/)
    
    i1=0
    do ic=1, gf%nchr
       nsnp = gf%ichr(ic)%nsnp
       allocate(f(nsnp),ixpos(nsnp)) !--> size # snps in chr
       ixpos =(/(i,i=1,nsnp)/)
       f=0.
       do i=1, nind
          f = f(:) + ind(i)%g%ichr(ic)%snp(:,1) + ind(i)%g%ichr(ic)%snp(:,2)
       enddo
       f = 0.5*f/nind
       where(f>0.5) f=1.-f       !--> maf ensured <= 0.5
       where(f<chip%maf) ixpos=0 !--> discard if below maf
       !print*, count(ixpos>0)
       i2=i1+nsnp
       itpos(i1+1:i2,1) = ixpos  !--> contains indices of choosable markers & chr
       itpos(i1+1:i2,2) = ic
       i1=i2
       deallocate(f,ixpos)
    enddo
    
    !--> total no. potential markers
    nsnp = count(itpos(:,1)>0)
    itpos(1:nsnp,3) = pack(itpos(:,3),itpos(:,1)>0)
    !--> removes randomly p % markers
    if (chip%p<1.) then
       call random_permu(itpos(1:nsnp,3))
       nsnp = nsnp * chip%p   !--> no. markers to be retained
    endif

    !--> I assign ids to every marker
    do ic=1, gf%nchr
       if(associated(gf%ichr(ic)%chip)) deallocate(gf%ichr(ic)%chip)
       nchip = count(itpos(itpos(1:nsnp,3),2)==ic)
       gf%ichr(ic)%nchip = nchip
       if (nchip>0) then
          allocate(gf%ichr(ic)%chip(nchip))
          gf%ichr(ic)%chip = pack(itpos(itpos(1:nsnp,3),1), itpos(itpos(1:nsnp,3),2)==ic)
          call sortmat2(gf%ichr(ic)%chip)
       endif
    enddo
    deallocate(itpos)
 endif
!--------------
 end subroutine
!--------------

!----------------
 subroutine nums2 (a, n, x, xc)
!----------------
! separates array a into items delimited by blanks. character elements are
! put into optional character vector xc, decoded numeric values
! into optional real vector x, and n contains the number of items. The
! dimension of x and xc can be lower than n.
! format changed slightly to read real numbers in scientific notation (mpe)
! 2/23/2000 IMisztal

 character (*)          :: a
 character (*),optional :: xc(:)
 real,optional          :: x(:)
 integer :: n, curr, first, last, lena, stat, i

 curr=1
 lena=len(a)
 n=0

 do
   !--> search for first nonspace
   first=0
   do i=curr,lena
     if (a(i:i) /= ' ') then
        first=i
        exit
     endif
   enddo
   if (first == 0) exit

   !--> search for first space
   curr=first+1
   last=0
   do i=curr,lena
      if (a(i:i) == ' ') then
        last=i
        exit
      endif
   enddo

   if (last == 0) last=lena

   n=n+1
   if (present(xc)) then
      if (size(xc) >= n) then
         xc(n)=a(first:last)
      else
         print*, 'NUMS2: Increase size of XC'
      endif
   endif

   if (present(x)) then
      if (size(x) >= n) then
        read(a(first:last),*,iostat=stat) x(n)    !NEW (mpe)
        if (stat .ne. 0) x(n)=0
      else
         print*, 'NUMS2: Increase size of X'
      endif
   endif

   curr=last+1
 enddo
!--------------
 end subroutine
!--------------


!######################
 END PROGRAM ms2gs
!######################
